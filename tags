!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BitAnd	src/mat.rs	/^impl<'a> BitAnd for &'a Mat {$/;"	i
BitAnd for Mat	src/mat.rs	/^impl BitAnd for Mat {$/;"	i
BitOr	src/mat.rs	/^impl<'a> BitOr for &'a Mat {$/;"	i
BitOr for Mat	src/mat.rs	/^impl BitOr for Mat {$/;"	i
BitXor	src/mat.rs	/^impl<'a> BitXor for &'a Mat {$/;"	i
BitXor for Mat	src/mat.rs	/^impl BitXor for Mat {$/;"	i
BorderType	src/mat.rs	/^impl BorderType {$/;"	i
BorderType	src/mat.rs	/^pub enum BorderType {$/;"	g
BuildError	build.rs	/^struct BuildError {$/;"	s
CCascadeClassifier	src/objdetect.rs	/^enum CCascadeClassifier {}$/;"	g
CDescriptorMatcher	src/features2d/descriptor_matcher.rs	/^enum CDescriptorMatcher {}$/;"	g
CDisposableString	native/common.h	/^} CDisposableString;$/;"	t	typeref:struct:__anon11
CDisposableString	src/lib.rs	/^struct CDisposableString {$/;"	s
CGpuCascade	src/cuda.rs	/^pub enum CGpuCascade {}$/;"	g
CGpuHog	src/cuda.rs	/^pub enum CGpuHog {}$/;"	g
CGpuMat	src/cuda.rs	/^pub enum CGpuMat {}$/;"	g
CHogDescriptor	src/objdetect.rs	/^enum CHogDescriptor {}$/;"	g
CMSER	src/features2d/mser.rs	/^enum CMSER {}$/;"	g
CMat	src/mat.rs	/^impl CMat {$/;"	i
CMat	src/mat.rs	/^pub enum CMat {}$/;"	g
COCR	src/text/mod.rs	/^    pub enum COCR {}$/;"	g
CResult	src/lib.rs	/^impl<T: Copy> CResult<T> {$/;"	i
CResult	src/lib.rs	/^struct CResult<T: Copy> {$/;"	s
CSIFT	src/features2d/sift.rs	/^enum CSIFT {}$/;"	g
CSURF	src/features2d/surf.rs	/^enum CSURF {}$/;"	g
CSvmDetector	src/objdetect.rs	/^pub enum CSvmDetector {}$/;"	g
CTermCriteria	src/video.rs	/^    enum CTermCriteria {}$/;"	g
CV_RS_COMMON_H	native/common.h	2;"	d
CV_RS_COMMON_RUST_H	native/common-rust.h	2;"	d
CV_RS_FEATURES2D_H	native/features2d.h	2;"	d
CV_RS_HIGHGUI_H	native/highgui.h	2;"	d
CV_RS_IMCODECS_H	native/imcodecs.h	2;"	d
CV_RS_IMGPROC_H	native/imgproc.h	2;"	d
CV_RS_MAT_H	native/mat.h	2;"	d
CV_RS_OBJDETECT_H	native/objdetect.h	2;"	d
CV_RS_TEXT_H	native/text.h	2;"	d
CV_RS_VIDEOIO_H	native/videoio.h	2;"	d
CV_RS_VIDEO_H	native/video.h	2;"	d
CVec	native/common.h	/^struct CVec {$/;"	s
CVideoCapture	src/videoio.rs	/^enum CVideoCapture {}$/;"	g
CallbackWrapper	src/highgui.rs	/^    struct CallbackWrapper {$/;"	s
CapProp	src/videoio.rs	/^pub enum CapProp {$/;"	g
CascadeClassifier	src/objdetect.rs	/^impl CascadeClassifier {$/;"	i
CascadeClassifier	src/objdetect.rs	/^pub struct CascadeClassifier {$/;"	s
ClassifierType	src/text/hmm.rs	/^pub enum ClassifierType {$/;"	g
ColorConversion	src/imgproc.rs	/^pub enum ColorConversion {$/;"	g
ComponentLevel	src/text/mod.rs	/^pub enum ComponentLevel {$/;"	g
CvError	src/errors.rs	/^pub enum CvError {$/;"	g
CvType	src/core.rs	/^pub enum CvType {$/;"	g
CvVideoWriter	src/videoio.rs	/^enum CvVideoWriter {}$/;"	g
DEFAULT_NLEVELS	src/objdetect.rs	/^const DEFAULT_NLEVELS: usize = 64;$/;"	c
DEFAULT_WIN_SIGMA	src/objdetect.rs	/^const DEFAULT_WIN_SIGMA: f64 = -1f64;$/;"	c
DMatch	native/common.h	/^} DMatch;$/;"	t	typeref:struct:__anon10
DMatch	src/features2d/descriptor_matcher.rs	/^pub struct DMatch {$/;"	s
Default	src/mat.rs	/^    pub const Default: BorderType = BorderType::Reflect101;$/;"	c
Default for CDisposableString	src/lib.rs	/^impl Default for CDisposableString {$/;"	i
Default for CVec	src/lib.rs	/^impl<T: NestedVec> Default for CVec<T> {$/;"	i
Default for GpuHog	src/cuda.rs	/^impl Default for GpuHog {$/;"	i
Default for HogDescriptor	src/objdetect.rs	/^impl Default for HogDescriptor {$/;"	i
Default for HogParams	src/objdetect.rs	/^impl Default for HogParams {$/;"	i
Default for VideoWriter	src/videoio.rs	/^impl Default for VideoWriter {$/;"	i
DescriptorMatcher	src/features2d/descriptor_matcher.rs	/^impl DescriptorMatcher {$/;"	i
DescriptorMatcher	src/features2d/descriptor_matcher.rs	/^pub struct DescriptorMatcher {$/;"	s
DescriptorMatcherType	src/features2d/descriptor_matcher.rs	/^impl DescriptorMatcherType {$/;"	i
DescriptorMatcherType	src/features2d/descriptor_matcher.rs	/^pub enum DescriptorMatcherType {$/;"	g
Drop for CDisposableString	src/lib.rs	/^impl Drop for CDisposableString {$/;"	i
Drop for CVec	src/lib.rs	/^impl<T: NestedVec> Drop for CVec<T> {$/;"	i
Drop for CVecView	src/lib.rs	/^impl<T> Drop for CVecView<T> {$/;"	i
Drop for CascadeClassifier	src/objdetect.rs	/^impl Drop for CascadeClassifier {$/;"	i
Drop for DescriptorMatcher	src/features2d/descriptor_matcher.rs	/^impl Drop for DescriptorMatcher {$/;"	i
Drop for GpuCascade	src/cuda.rs	/^impl Drop for GpuCascade {$/;"	i
Drop for GpuHog	src/cuda.rs	/^impl Drop for GpuHog {$/;"	i
Drop for GpuMat	src/cuda.rs	/^impl Drop for GpuMat {$/;"	i
Drop for HogDescriptor	src/objdetect.rs	/^impl Drop for HogDescriptor {$/;"	i
Drop for MSER	src/features2d/mser.rs	/^impl Drop for MSER {$/;"	i
Drop for Mat	src/mat.rs	/^impl Drop for Mat {$/;"	i
Drop for OcrHmmDecoder	src/text/hmm.rs	/^impl Drop for OcrHmmDecoder {$/;"	i
Drop for OcrHolisticWord	src/text/holisticword.rs	/^impl Drop for OcrHolisticWord {$/;"	i
Drop for OcrTesseract	src/text/tesseract.rs	/^impl Drop for OcrTesseract {$/;"	i
Drop for SIFT	src/features2d/sift.rs	/^impl Drop for SIFT {$/;"	i
Drop for SURF	src/features2d/surf.rs	/^impl Drop for SURF {$/;"	i
Drop for SvmDetector	src/objdetect.rs	/^impl Drop for SvmDetector {$/;"	i
Drop for TermCriteria	src/video.rs	/^    impl Drop for TermCriteria {$/;"	i
Drop for VideoCapture	src/videoio.rs	/^impl Drop for VideoCapture {$/;"	i
Drop for VideoWriter	src/videoio.rs	/^impl Drop for VideoWriter {$/;"	i
EngineMode	src/text/tesseract.rs	/^pub enum EngineMode {$/;"	g
FIRST_IMAGE_PATH	tests/test_imgproc.rs	/^const FIRST_IMAGE_PATH: &str = "assets\/Histogram_Comparison_Source_0.png";$/;"	c
Feature2D	src/features2d/mod.rs	/^pub trait Feature2D {$/;"	t
Feature2D for SIFT	src/features2d/sift.rs	/^impl Feature2D for SIFT {$/;"	i
Feature2D for SURF	src/features2d/surf.rs	/^impl Feature2D for SURF {$/;"	i
FlipCode	src/core.rs	/^pub enum FlipCode {$/;"	g
From for GpuMat	src/cuda.rs	/^impl From<Mat> for GpuMat {$/;"	i
From for Mat	src/cuda.rs	/^impl From<GpuMat> for Mat {$/;"	i
FromBytes	src/core.rs	/^impl<T: FromBytes> FromBytes for (T, T, T) {$/;"	i
FromBytes	src/core.rs	/^pub trait FromBytes {$/;"	t
FromBytes for f32	src/core.rs	/^impl FromBytes for f32 {$/;"	i
FromBytes for f64	src/core.rs	/^impl FromBytes for f64 {$/;"	i
FromBytes for i16	src/core.rs	/^impl FromBytes for i16 {$/;"	i
FromBytes for i32	src/core.rs	/^impl FromBytes for i32 {$/;"	i
FromBytes for i8	src/core.rs	/^impl FromBytes for i8 {$/;"	i
FromBytes for u16	src/core.rs	/^impl FromBytes for u16 {$/;"	i
FromBytes for u8	src/core.rs	/^impl FromBytes for u8 {$/;"	i
FromFunction	native/common.h	/^    static Result<T> FromFunction(std::function<T()> function) {$/;"	f	struct:Result
GpuCascade	src/cuda.rs	/^impl GpuCascade {$/;"	i
GpuCascade	src/cuda.rs	/^pub struct GpuCascade {$/;"	s
GpuHog	src/cuda.rs	/^impl GpuHog {$/;"	i
GpuHog	src/cuda.rs	/^pub struct GpuHog {$/;"	s
GpuMat	src/cuda.rs	/^impl GpuMat {$/;"	i
GpuMat	src/cuda.rs	/^pub struct GpuMat {$/;"	s
HistogramComparisionMethod	src/imgproc.rs	/^pub enum HistogramComparisionMethod {$/;"	g
HogDescriptor	src/objdetect.rs	/^impl HogDescriptor {$/;"	i
HogDescriptor	src/objdetect.rs	/^pub struct HogDescriptor {$/;"	s
HogParams	src/objdetect.rs	/^pub struct HogParams {$/;"	s
ImageReadMode	src/imgcodecs.rs	/^pub enum ImageReadMode {$/;"	g
ImageWriteMode	src/imgcodecs.rs	/^pub enum ImageWriteMode {$/;"	g
ImageWritePngStrategy	src/imgcodecs.rs	/^pub enum ImageWritePngStrategy {$/;"	g
ImencodeResult	native/imcodecs.h	/^} ImencodeResult;$/;"	t	typeref:struct:__anon1
ImencodeResult	src/imgcodecs.rs	/^struct ImencodeResult {$/;"	s
In	src/lib.rs	/^    type In = T;$/;"	T
In	src/lib.rs	/^    type In = Vec<T::In>;$/;"	T
In	src/lib.rs	/^    type In;$/;"	T
InterpolationFlag	src/imgproc.rs	/^pub enum InterpolationFlag {$/;"	g
Into	src/lib.rs	/^impl<T: Copy> Into<Result<T, String>> for CResult<T> {$/;"	i
Into for MSERBuilder	src/features2d/mser.rs	/^impl Into<MSER> for MSERBuilder {$/;"	i
Into for Mat	src/mat.rs	/^impl Into<CMat> for Mat {$/;"	i
Into for SIFTBuilder	src/features2d/sift.rs	/^impl Into<SIFT> for SIFTBuilder {$/;"	i
Into for SURFBuilder	src/features2d/surf.rs	/^impl Into<SURF> for SURFBuilder {$/;"	i
K	tests/test_features2d.rs	/^    const K: usize = 3;$/;"	c
KeyPoint	native/common.h	/^} KeyPoint;$/;"	t	typeref:struct:__anon9
KeyPoint	src/core.rs	/^pub struct KeyPoint {$/;"	s
LEVEL	src/lib.rs	/^    const LEVEL: u32 = 0;$/;"	c
LEVEL	src/lib.rs	/^    const LEVEL: u32 = T::LEVEL + 1;$/;"	c
LEVEL	src/lib.rs	/^    const LEVEL: u32;$/;"	c
LineType	src/core.rs	/^pub enum LineType {$/;"	g
MSER	src/features2d/mser.rs	/^impl MSER {$/;"	i
MSER	src/features2d/mser.rs	/^pub struct MSER {$/;"	s
MSERBuilder	src/features2d/mser.rs	/^impl MSERBuilder {$/;"	i
MSERBuilder	src/features2d/mser.rs	/^pub struct MSERBuilder {$/;"	s
Mat	src/imgcodecs.rs	/^impl Mat {$/;"	i
Mat	src/imgproc.rs	/^impl Mat {$/;"	i
Mat	src/mat.rs	/^impl Mat {$/;"	i
Mat	src/mat.rs	/^pub struct Mat {$/;"	s
Mat	src/video.rs	/^    impl Mat {$/;"	i
MouseCallback	src/highgui.rs	/^pub type MouseCallback = fn(MouseEventType, c_int, c_int, c_int, MouseCallbackData);$/;"	T
MouseCallbackData	src/highgui.rs	/^pub type MouseCallbackData = *mut c_void;$/;"	T
MouseEventType	src/highgui.rs	/^pub enum MouseEventType {$/;"	g
NestedVec for CDisposableString	src/lib.rs	/^impl NestedVec for CDisposableString {$/;"	i
NestedVec for CVec	src/lib.rs	/^impl<T: NestedVec> NestedVec for CVec<T> {$/;"	i
NestedVec for T	src/lib.rs	/^impl<T: Copy> NestedVec for T {$/;"	i
NormType	src/core.rs	/^pub enum NormType {$/;"	g
Not	src/mat.rs	/^impl<'a> Not for &'a Mat {$/;"	i
Not for Mat	src/mat.rs	/^impl Not for Mat {$/;"	i
OPENCV_CUDA_H_	native/cuda/cuda.h	2;"	d
ObjectDetect	src/objdetect.rs	/^pub trait ObjectDetect {$/;"	t
ObjectDetect for CascadeClassifier	src/objdetect.rs	/^impl ObjectDetect for CascadeClassifier {$/;"	i
ObjectDetect for GpuCascade	src/cuda.rs	/^impl ObjectDetect for GpuCascade {$/;"	i
ObjectDetect for GpuHog	src/cuda.rs	/^impl ObjectDetect for GpuHog {$/;"	i
ObjectDetect for HogDescriptor	src/objdetect.rs	/^impl ObjectDetect for HogDescriptor {$/;"	i
Ocr	src/text/mod.rs	/^pub trait Ocr {$/;"	t
Ocr for T	src/text/mod.rs	/^impl<T: OcrImplInterface> Ocr for T {$/;"	i
OcrHmmDecoder	src/text/hmm.rs	/^impl OcrHmmDecoder {$/;"	i
OcrHmmDecoder	src/text/hmm.rs	/^pub struct OcrHmmDecoder {$/;"	s
OcrHolisticWord	src/text/holisticword.rs	/^impl OcrHolisticWord {$/;"	i
OcrHolisticWord	src/text/holisticword.rs	/^pub struct OcrHolisticWord {$/;"	s
OcrImpl	src/text/mod.rs	/^    pub trait OcrImpl {$/;"	t
OcrImpl for OcrHmmDecoder	src/text/hmm.rs	/^impl OcrImpl for OcrHmmDecoder {$/;"	i
OcrImpl for OcrHolisticWord	src/text/holisticword.rs	/^impl OcrImpl for OcrHolisticWord {$/;"	i
OcrImpl for OcrTesseract	src/text/tesseract.rs	/^impl OcrImpl for OcrTesseract {$/;"	i
OcrImplInterface	src/text/mod.rs	/^pub trait OcrImplInterface: private::OcrImpl {}$/;"	t
OcrImplInterface for OcrHmmDecoder	src/text/hmm.rs	/^impl OcrImplInterface for OcrHmmDecoder {}$/;"	i
OcrImplInterface for OcrHolisticWord	src/text/holisticword.rs	/^impl OcrImplInterface for OcrHolisticWord {}$/;"	i
OcrImplInterface for OcrTesseract	src/text/tesseract.rs	/^impl OcrImplInterface for OcrTesseract {}$/;"	i
OcrTesseract	src/text/tesseract.rs	/^impl OcrTesseract {$/;"	i
OcrTesseract	src/text/tesseract.rs	/^pub struct OcrTesseract {$/;"	s
Out	src/lib.rs	/^    type Out = String;$/;"	T
Out	src/lib.rs	/^    type Out = T;$/;"	T
Out	src/lib.rs	/^    type Out = Vec<T::Out>;$/;"	T
Out	src/lib.rs	/^    type Out;$/;"	T
Output	src/mat.rs	/^    type Output = Mat;$/;"	T
Output	src/mat.rs	/^    type Output = Self;$/;"	T
Pack for CVecView	src/lib.rs	/^impl<T: Pack> Pack for CVecView<T> {$/;"	i
Pack for T	src/lib.rs	/^impl<T: Copy> Pack for T {$/;"	i
PageSegmentationMode	src/text/tesseract.rs	/^pub enum PageSegmentationMode {$/;"	g
Point2f	native/common.h	/^} Point2f;$/;"	t	typeref:struct:__anon3
Point2f	src/core.rs	/^impl Point2f {$/;"	i
Point2f	src/core.rs	/^pub struct Point2f {$/;"	s
Point2i	native/common.h	/^} Point2i;$/;"	t	typeref:struct:__anon2
Point2i	src/core.rs	/^impl Point2i {$/;"	i
Point2i	src/core.rs	/^pub struct Point2i {$/;"	s
Rect	native/common.h	/^} Rect;$/;"	t	typeref:struct:__anon6
Rect	src/core.rs	/^impl Rect {$/;"	i
Rect	src/core.rs	/^pub struct Rect {$/;"	s
Rect2f	src/core.rs	/^impl Rect2f {$/;"	i
Rect2f	src/core.rs	/^pub struct Rect2f {$/;"	s
Result	native/common.h	/^struct Result {$/;"	s
RotatedRect	native/common.h	/^} RotatedRect;$/;"	t	typeref:struct:__anon7
RotatedRect	src/core.rs	/^impl RotatedRect {$/;"	i
RotatedRect	src/core.rs	/^pub struct RotatedRect {$/;"	s
SECOND_IMAGE_PATH	tests/test_imgproc.rs	/^const SECOND_IMAGE_PATH: &str = "assets\/Histogram_Comparison_Source_1.png";$/;"	c
SIFT	src/features2d/sift.rs	/^impl SIFT {$/;"	i
SIFT	src/features2d/sift.rs	/^pub struct SIFT {$/;"	s
SIFTBuilder	src/features2d/sift.rs	/^impl SIFTBuilder {$/;"	i
SIFTBuilder	src/features2d/sift.rs	/^pub struct SIFTBuilder {$/;"	s
SURF	src/features2d/surf.rs	/^impl SURF {$/;"	i
SURF	src/features2d/surf.rs	/^pub struct SURF {$/;"	s
SURFBuilder	src/features2d/surf.rs	/^impl SURFBuilder {$/;"	i
SURFBuilder	src/features2d/surf.rs	/^pub struct SURFBuilder {$/;"	s
Scalar	native/common.h	/^} Scalar;$/;"	t	typeref:struct:__anon8
Scalar	src/core.rs	/^impl Scalar {$/;"	i
Scalar	src/core.rs	/^pub struct Scalar {$/;"	s
SelectionStatus	examples/camshift.rs	/^struct SelectionStatus {$/;"	s
Send for CMat	src/mat.rs	/^unsafe impl Send for CMat {}$/;"	i
Send for CVideoCapture	src/videoio.rs	/^unsafe impl Send for CVideoCapture {}$/;"	i
Send for CascadeClassifier	src/objdetect.rs	/^unsafe impl Send for CascadeClassifier {}$/;"	i
Send for GpuCascade	src/cuda.rs	/^unsafe impl Send for GpuCascade {}$/;"	i
Send for GpuHog	src/cuda.rs	/^unsafe impl Send for GpuHog {}$/;"	i
Send for HogDescriptor	src/objdetect.rs	/^unsafe impl Send for HogDescriptor {}$/;"	i
Send for Mat	src/mat.rs	/^unsafe impl Send for Mat {}$/;"	i
Send for VideoCapture	src/videoio.rs	/^unsafe impl Send for VideoCapture {}$/;"	i
Show	src/highgui.rs	/^pub trait Show {$/;"	t
Show for Mat	src/highgui.rs	/^impl Show for Mat {$/;"	i
Size2f	native/common.h	/^} Size2f;$/;"	t	typeref:struct:__anon5
Size2f	src/core.rs	/^pub struct Size2f {$/;"	s
Size2i	native/common.h	/^} Size2i;$/;"	t	typeref:struct:__anon4
Size2i	src/core.rs	/^impl Size2i {$/;"	i
Size2i	src/core.rs	/^pub struct Size2i {$/;"	s
SvmDetector	src/objdetect.rs	/^impl SvmDetector {$/;"	i
SvmDetector	src/objdetect.rs	/^pub struct SvmDetector {$/;"	s
TermCriteria	src/video.rs	/^    impl TermCriteria {$/;"	i
TermCriteria	src/video.rs	/^    pub struct TermCriteria {$/;"	s
TermType	src/video.rs	/^    pub enum TermType {$/;"	g
UTILS_H_	native/utils.cc	2;"	d	file:
UTILS_H_	native/utils.h	2;"	d
Unpack for CDisposableString	src/lib.rs	/^impl Unpack for CDisposableString {$/;"	i
Unpack for CVec	src/lib.rs	/^impl<T: Unpack + NestedVec> Unpack for CVec<T> {$/;"	i
Unpack for T	src/lib.rs	/^impl<T: Copy> Unpack for T {$/;"	i
VOCABULARY	tests/test_text.rs	/^const VOCABULARY: &str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";$/;"	c
VideoCapture	src/videoio.rs	/^impl VideoCapture {$/;"	i
VideoCapture	src/videoio.rs	/^pub struct VideoCapture {$/;"	s
VideoWriter	src/videoio.rs	/^impl VideoWriter {$/;"	i
VideoWriter	src/videoio.rs	/^pub struct VideoWriter {$/;"	s
VideoWriterProperty	src/videoio.rs	/^pub enum VideoWriterProperty {$/;"	g
WindowFlag	src/highgui.rs	/^pub enum WindowFlag {$/;"	g
_detect	src/cuda.rs	/^    fn _detect(&self, mat: &GpuMat) -> Vec<(Rect, f64)> {$/;"	f
_detect_with_confidence	src/cuda.rs	/^    fn _detect_with_confidence(&self, mat: &GpuMat) -> Vec<(Rect, f64)> {$/;"	f
_mouse_callback	src/highgui.rs	/^    extern "C" fn _mouse_callback(e: MouseEventType, x: c_int, y: c_int, f: c_int, ud: *mut c_void) {$/;"	f
add	src/features2d/descriptor_matcher.rs	/^    pub fn add(&self, descriptors: &Vec<&Mat>) {$/;"	f
all	src/core.rs	/^    pub fn all(v: c_int) -> Self {$/;"	f
analysis	src/video.rs	/^pub mod analysis {$/;"	m
angle	native/common.h	/^    float angle;$/;"	m	struct:__anon7
angle	native/common.h	/^    float angle;$/;"	m	struct:__anon9
area_threshold	src/features2d/mser.rs	/^    pub fn area_threshold(mut self, value: f64) -> Self {$/;"	f
array	native/common.h	/^    T* array;$/;"	m	struct:CVec
assert_contains	tests/test_text.rs	/^    fn assert_contains(left: &str, right: &str) {$/;"	f
assert_eq	tests/test_imgproc.rs	/^fn assert_eq(a: f64, b: f64) {$/;"	f
at	src/mat.rs	/^    pub fn at<T: FromBytes>(&self, i0: i32) -> T {$/;"	f
at2	src/mat.rs	/^    pub fn at2<T: FromBytes>(&self, i0: i32, i1: i32) -> T {$/;"	f
at3	src/mat.rs	/^    pub fn at3<T: FromBytes>(&self, i0: i32, i1: i32, i2: i32) -> T {$/;"	f
bench_decode_lenna	tests/benchmark.rs	/^fn bench_decode_lenna() {$/;"	f
bench_face_detect_physicists	tests/benchmark.rs	/^fn bench_face_detect_physicists() {$/;"	f
bench_mat_new	tests/benchmark.rs	/^fn bench_mat_new() {$/;"	f
bitand	src/mat.rs	/^    fn bitand(self, rhs: &'a Mat) -> Self::Output {$/;"	f
bitand	src/mat.rs	/^    fn bitand(self, rhs: Self) -> Self::Output {$/;"	f
bitor	src/mat.rs	/^    fn bitor(self, rhs: &'a Mat) -> Self::Output {$/;"	f
bitor	src/mat.rs	/^    fn bitor(self, rhs: Self) -> Self::Output {$/;"	f
bitxor	src/mat.rs	/^    fn bitxor(self, rhs: &'a Mat) -> Self::Output {$/;"	f
bitxor	src/mat.rs	/^    fn bitxor(self, rhs: Self) -> Self::Output {$/;"	f
bounding_rect	src/core.rs	/^    pub fn bounding_rect(&self) -> Rect {$/;"	f
buf	native/imcodecs.h	/^    uint8_t* buf;$/;"	m	struct:__anon1
c_drop	native/common-rust.cc	/^void c_drop(void* value) {$/;"	f
c_drop	src/lib.rs	/^    fn c_drop(value: *mut c_void);$/;"	f
calc_back_project	src/imgproc.rs	/^    pub fn calc_back_project<T: AsRef<[c_int]>, MElem: AsRef<[f32]>, M: AsRef<[MElem]>>($/;"	f
calc_hist	src/imgproc.rs	/^    pub fn calc_hist<T: AsRef<[c_int]>, U: AsRef<[c_int]>, MElem: AsRef<[f32]>, M: AsRef<[MElem]>>($/;"	f
camshift	src/video.rs	/^        pub fn camshift(&self, wndw: Rect, criteria: &TermCriteria) -> RotatedRect {$/;"	f
cascade_model_path	tests/test_objdetect.rs	/^fn cascade_model_path() -> &'static str {$/;"	f
center	native/common.h	/^    Point2f center;$/;"	m	struct:__anon7
class_id	native/common.h	/^    int class_id;$/;"	m	struct:__anon9
close_rect	tests/utils.rs	/^pub fn close_rect(a: Rect, b: Rect, epsilon: i32) -> bool {$/;"	f
codec_name_from_4cc	src/videoio.rs	/^pub fn codec_name_from_4cc(value: &str) -> Result<u32, Error> {$/;"	f
codec_name_to_4cc	src/videoio.rs	/^pub fn codec_name_to_4cc(value: u32) -> String {$/;"	f
compare_hist	src/imgproc.rs	/^    pub fn compare_hist(&self, other: &Mat, method: HistogramComparisionMethod) -> Result<f64, String> {$/;"	f
compare_hist	tests/test_imgproc.rs	/^fn compare_hist(method: HistogramComparisionMethod, expected_result: f64) {$/;"	f
compare_hist_bhattacharyya	tests/test_imgproc.rs	/^fn compare_hist_bhattacharyya() {$/;"	f
compare_hist_chi_square	tests/test_imgproc.rs	/^fn compare_hist_chi_square() {$/;"	f
compare_hist_chi_square_alternative	tests/test_imgproc.rs	/^fn compare_hist_chi_square_alternative() {$/;"	f
compare_hist_correlation	tests/test_imgproc.rs	/^fn compare_hist_correlation() {$/;"	f
compare_hist_different_dimensions_panic	tests/test_imgproc.rs	/^fn compare_hist_different_dimensions_panic() {$/;"	f
compare_hist_intersection	tests/test_imgproc.rs	/^fn compare_hist_intersection() {$/;"	f
compare_hist_kullback_leibler_divergence	tests/test_imgproc.rs	/^fn compare_hist_kullback_leibler_divergence() {$/;"	f
contrast_threshold	src/features2d/sift.rs	/^    pub fn contrast_threshold(mut self, value: f64) -> Self {$/;"	f
copy_make_border	src/mat.rs	/^    pub fn copy_make_border($/;"	f
core	src/lib.rs	/^pub mod core;$/;"	m
count_non_zero	src/mat.rs	/^    pub fn count_non_zero(&self) -> c_int {$/;"	f
cuda	src/lib.rs	/^pub mod cuda;$/;"	m
cv_calc_back_project	native/imgproc.cc	/^void cv_calc_back_project(const cv::Mat* images,$/;"	f
cv_calc_back_project	src/imgproc.rs	/^    fn cv_calc_back_project($/;"	f
cv_calc_hist	native/imgproc.cc	/^void cv_calc_hist(const cv::Mat* images,$/;"	f
cv_calc_hist	src/imgproc.rs	/^    fn cv_calc_hist($/;"	f
cv_camshift	native/video.cc	/^RotatedRect cv_camshift(cv::Mat* bp_image, Rect crect, cv::TermCriteria* criteria) {$/;"	f
cv_camshift	src/video.rs	/^        fn cv_camshift(image: *mut CMat, w: Rect, c_criteria: *const CTermCriteria) -> RotatedRect;$/;"	f
cv_cascade_classifier_detect	native/objdetect.cc	/^void cv_cascade_classifier_detect(cv::CascadeClassifier* cascade,$/;"	f
cv_cascade_classifier_detect	src/objdetect.rs	/^    fn cv_cascade_classifier_detect($/;"	f
cv_cascade_classifier_drop	native/objdetect.cc	/^void cv_cascade_classifier_drop(cv::CascadeClassifier* cascade) {$/;"	f
cv_cascade_classifier_drop	src/objdetect.rs	/^    fn cv_cascade_classifier_drop(p: *mut CCascadeClassifier);$/;"	f
cv_cascade_classifier_from_path	native/objdetect.cc	/^void* cv_cascade_classifier_from_path(const char* const p) {$/;"	f
cv_cascade_classifier_load	native/objdetect.cc	/^bool cv_cascade_classifier_load(cv::CascadeClassifier* cascade, const char* const p) {$/;"	f
cv_cascade_classifier_load	src/objdetect.rs	/^    fn cv_cascade_classifier_load(cc: *mut CCascadeClassifier, p: *const c_char) -> bool;$/;"	f
cv_cascade_classifier_new	native/objdetect.cc	/^void* cv_cascade_classifier_new() {$/;"	f
cv_cascade_classifier_new	src/objdetect.rs	/^    fn cv_cascade_classifier_new() -> *mut CCascadeClassifier;$/;"	f
cv_compare_hist	native/imgproc.cc	/^void cv_compare_hist(cv::Mat* first_image, cv::Mat* second_image, int method, Result<double>* result) {$/;"	f
cv_compare_hist	src/imgproc.rs	/^    fn cv_compare_hist($/;"	f
cv_cuda_cascade_detect	native/cuda/cuda.cc	/^void cv_cuda_cascade_detect(cv::Ptr<cv::cuda::CascadeClassifier>* cascade,$/;"	f
cv_cuda_cascade_detect	src/cuda.rs	/^    fn cv_cuda_cascade_detect(cascade: *mut CGpuCascade, image: *const CGpuMat, objects: *mut CVec<Rect>);$/;"	f
cv_cuda_cascade_drop	native/cuda/cuda.cc	/^void cv_cuda_cascade_drop(cv::Ptr<cv::cuda::CascadeClassifier>* cascade) {$/;"	f
cv_cuda_cascade_drop	src/cuda.rs	/^    fn cv_cuda_cascade_drop(cascade: *mut CGpuCascade);$/;"	f
cv_cuda_cascade_get_classifier_size	native/cuda/cuda.cc	/^Size2i cv_cuda_cascade_get_classifier_size(cv::Ptr<cv::cuda::CascadeClassifier>* cascade) {$/;"	f
cv_cuda_cascade_get_classifier_size	src/cuda.rs	/^    fn cv_cuda_cascade_get_classifier_size(cascade: *const CGpuCascade) -> Size2i;$/;"	f
cv_cuda_cascade_get_find_largest_object	native/cuda/cuda.cc	/^bool cv_cuda_cascade_get_find_largest_object(cv::Ptr<cv::cuda::CascadeClassifier>* cascade) {$/;"	f
cv_cuda_cascade_get_find_largest_object	src/cuda.rs	/^    fn cv_cuda_cascade_get_find_largest_object(cascade: *const CGpuCascade) -> bool;$/;"	f
cv_cuda_cascade_get_max_num_objects	native/cuda/cuda.cc	/^int cv_cuda_cascade_get_max_num_objects(cv::Ptr<cv::cuda::CascadeClassifier>* cascade) {$/;"	f
cv_cuda_cascade_get_max_num_objects	src/cuda.rs	/^    fn cv_cuda_cascade_get_max_num_objects(cascade: *const CGpuCascade) -> c_int;$/;"	f
cv_cuda_cascade_get_max_object_size	native/cuda/cuda.cc	/^Size2i cv_cuda_cascade_get_max_object_size(cv::Ptr<cv::cuda::CascadeClassifier>* cascade) {$/;"	f
cv_cuda_cascade_get_max_object_size	src/cuda.rs	/^    fn cv_cuda_cascade_get_max_object_size(cascade: *const CGpuCascade) -> Size2i;$/;"	f
cv_cuda_cascade_get_min_neighbors	native/cuda/cuda.cc	/^int cv_cuda_cascade_get_min_neighbors(cv::Ptr<cv::cuda::CascadeClassifier>* cascade) {$/;"	f
cv_cuda_cascade_get_min_neighbors	src/cuda.rs	/^    fn cv_cuda_cascade_get_min_neighbors(cascade: *const CGpuCascade) -> c_int;$/;"	f
cv_cuda_cascade_get_min_object_size	native/cuda/cuda.cc	/^Size2i cv_cuda_cascade_get_min_object_size(cv::Ptr<cv::cuda::CascadeClassifier>* cascade) {$/;"	f
cv_cuda_cascade_get_min_object_size	src/cuda.rs	/^    fn cv_cuda_cascade_get_min_object_size(cascade: *const CGpuCascade) -> Size2i;$/;"	f
cv_cuda_cascade_get_scale_factor	native/cuda/cuda.cc	/^double cv_cuda_cascade_get_scale_factor(cv::Ptr<cv::cuda::CascadeClassifier>* cascade) {$/;"	f
cv_cuda_cascade_get_scale_factor	src/cuda.rs	/^    fn cv_cuda_cascade_get_scale_factor(cascade: *const CGpuCascade) -> c_double;$/;"	f
cv_cuda_cascade_new	native/cuda/cuda.cc	/^void* cv_cuda_cascade_new(const char* const filename) {$/;"	f
cv_cuda_cascade_new	src/cuda.rs	/^    fn cv_cuda_cascade_new(filename: *const c_char) -> *mut CGpuCascade;$/;"	f
cv_cuda_cascade_set_find_largest_object	native/cuda/cuda.cc	/^void cv_cuda_cascade_set_find_largest_object(cv::Ptr<cv::cuda::CascadeClassifier>* cascade, bool value) {$/;"	f
cv_cuda_cascade_set_find_largest_object	src/cuda.rs	/^    fn cv_cuda_cascade_set_find_largest_object(cascade: *mut CGpuCascade, value: bool);$/;"	f
cv_cuda_cascade_set_max_num_objects	native/cuda/cuda.cc	/^void cv_cuda_cascade_set_max_num_objects(cv::Ptr<cv::cuda::CascadeClassifier>* cascade, int num) {$/;"	f
cv_cuda_cascade_set_max_num_objects	src/cuda.rs	/^    fn cv_cuda_cascade_set_max_num_objects(cascade: *mut CGpuCascade, max: c_int);$/;"	f
cv_cuda_cascade_set_max_object_size	native/cuda/cuda.cc	/^void cv_cuda_cascade_set_max_object_size(cv::Ptr<cv::cuda::CascadeClassifier>* cascade, Size2i max_size) {$/;"	f
cv_cuda_cascade_set_max_object_size	src/cuda.rs	/^    fn cv_cuda_cascade_set_max_object_size(cascade: *mut CGpuCascade, max: Size2i);$/;"	f
cv_cuda_cascade_set_min_neighbors	native/cuda/cuda.cc	/^void cv_cuda_cascade_set_min_neighbors(cv::Ptr<cv::cuda::CascadeClassifier>* cascade, int min) {$/;"	f
cv_cuda_cascade_set_min_neighbors	src/cuda.rs	/^    fn cv_cuda_cascade_set_min_neighbors(cascade: *mut CGpuCascade, min: c_int);$/;"	f
cv_cuda_cascade_set_min_object_size	native/cuda/cuda.cc	/^void cv_cuda_cascade_set_min_object_size(cv::Ptr<cv::cuda::CascadeClassifier>* cascade, Size2i min_size) {$/;"	f
cv_cuda_cascade_set_min_object_size	src/cuda.rs	/^    fn cv_cuda_cascade_set_min_object_size(cascade: *mut CGpuCascade, min: Size2i);$/;"	f
cv_cuda_cascade_set_scale_factor	native/cuda/cuda.cc	/^void cv_cuda_cascade_set_scale_factor(cv::Ptr<cv::cuda::CascadeClassifier>* cascade, double factor) {$/;"	f
cv_cuda_cascade_set_scale_factor	src/cuda.rs	/^    fn cv_cuda_cascade_set_scale_factor(cascade: *mut CGpuCascade, factor: c_double);$/;"	f
cv_cuda_gpu_mat_default	native/cuda/cuda.cc	/^void* cv_cuda_gpu_mat_default() {$/;"	f
cv_cuda_gpu_mat_default	src/cuda.rs	/^    fn cv_cuda_gpu_mat_default() -> *mut CGpuMat;$/;"	f
cv_cuda_gpu_mat_drop	native/cuda/cuda.cc	/^void cv_cuda_gpu_mat_drop(cv::cuda::GpuMat* gpu_image) {$/;"	f
cv_cuda_gpu_mat_drop	src/cuda.rs	/^    fn cv_cuda_gpu_mat_drop(gpu_mat: *mut CGpuMat);$/;"	f
cv_cuda_gpu_mat_from_mat	native/cuda/cuda.cc	/^void* cv_cuda_gpu_mat_from_mat(cv::Mat* image) {$/;"	f
cv_cuda_gpu_mat_from_mat	src/cuda.rs	/^    fn cv_cuda_gpu_mat_from_mat(mat: *mut CMat) -> *mut CGpuMat;$/;"	f
cv_cuda_gpu_mat_upload	native/cuda/cuda.cc	/^void cv_cuda_gpu_mat_upload(cv::cuda::GpuMat* gpu_image, cv::Mat* image) {$/;"	f
cv_cuda_gpu_mat_upload	src/cuda.rs	/^    fn cv_cuda_gpu_mat_upload(gpu_mat: *mut CGpuMat, cpu_mat: *const CMat);$/;"	f
cv_cuda_hog_default	native/cuda/cuda.cc	/^void* cv_cuda_hog_default() {$/;"	f
cv_cuda_hog_default	src/cuda.rs	/^    fn cv_cuda_hog_default() -> *mut CGpuHog;$/;"	f
cv_cuda_hog_detect	native/cuda/cuda.cc	/^void cv_cuda_hog_detect(cv::Ptr<cv::cuda::HOG>* hog, cv::cuda::GpuMat* image, CVec<Rect>* found) {$/;"	f
cv_cuda_hog_detect	src/cuda.rs	/^    fn cv_cuda_hog_detect(hog: *mut CGpuHog, mat: *mut CGpuMat, found: *mut CVec<Rect>);$/;"	f
cv_cuda_hog_detect_with_conf	native/cuda/cuda.cc	/^void cv_cuda_hog_detect_with_conf(cv::Ptr<cv::cuda::HOG>* hog,$/;"	f
cv_cuda_hog_detect_with_conf	src/cuda.rs	/^    fn cv_cuda_hog_detect_with_conf($/;"	f
cv_cuda_hog_drop	native/cuda/cuda.cc	/^void cv_cuda_hog_drop(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_drop	src/cuda.rs	/^    fn cv_cuda_hog_drop(hog: *mut CGpuHog);$/;"	f
cv_cuda_hog_get_gamma_correction	native/cuda/cuda.cc	/^bool cv_cuda_hog_get_gamma_correction(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_get_gamma_correction	src/cuda.rs	/^    fn cv_cuda_hog_get_gamma_correction(hog: *mut CGpuHog) -> bool;$/;"	f
cv_cuda_hog_get_group_threshold	native/cuda/cuda.cc	/^int cv_cuda_hog_get_group_threshold(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_get_group_threshold	src/cuda.rs	/^    fn cv_cuda_hog_get_group_threshold(hog: *mut CGpuHog) -> c_int;$/;"	f
cv_cuda_hog_get_hit_threshold	native/cuda/cuda.cc	/^double cv_cuda_hog_get_hit_threshold(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_get_hit_threshold	src/cuda.rs	/^    fn cv_cuda_hog_get_hit_threshold(hog: *mut CGpuHog) -> c_double;$/;"	f
cv_cuda_hog_get_l2hys_threshold	native/cuda/cuda.cc	/^double cv_cuda_hog_get_l2hys_threshold(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_get_l2hys_threshold	src/cuda.rs	/^    fn cv_cuda_hog_get_l2hys_threshold(hog: *mut CGpuHog) -> c_double;$/;"	f
cv_cuda_hog_get_num_levels	native/cuda/cuda.cc	/^int cv_cuda_hog_get_num_levels(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_get_num_levels	src/cuda.rs	/^    fn cv_cuda_hog_get_num_levels(hog: *mut CGpuHog) -> usize;$/;"	f
cv_cuda_hog_get_scale_factor	native/cuda/cuda.cc	/^double cv_cuda_hog_get_scale_factor(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_get_scale_factor	src/cuda.rs	/^    fn cv_cuda_hog_get_scale_factor(hog: *mut CGpuHog) -> c_double;$/;"	f
cv_cuda_hog_get_win_sigma	native/cuda/cuda.cc	/^double cv_cuda_hog_get_win_sigma(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_get_win_sigma	src/cuda.rs	/^    fn cv_cuda_hog_get_win_sigma(hog: *mut CGpuHog) -> c_double;$/;"	f
cv_cuda_hog_get_win_stride	native/cuda/cuda.cc	/^Size2i cv_cuda_hog_get_win_stride(cv::Ptr<cv::cuda::HOG>* hog) {$/;"	f
cv_cuda_hog_get_win_stride	src/cuda.rs	/^    fn cv_cuda_hog_get_win_stride(hog: *mut CGpuHog) -> Size2i;$/;"	f
cv_cuda_hog_new	native/cuda/cuda.cc	/^void* cv_cuda_hog_new(Size2i win_size, Size2i block_size, Size2i block_stride, Size2i cell_size, int nbins) {$/;"	f
cv_cuda_hog_new	src/cuda.rs	/^    fn cv_cuda_hog_new($/;"	f
cv_cuda_hog_set_detector	native/cuda/cuda.cc	/^void cv_cuda_hog_set_detector(cv::Ptr<cv::cuda::HOG>* hog, std::vector<float>* detector) {$/;"	f
cv_cuda_hog_set_detector	src/cuda.rs	/^    fn cv_cuda_hog_set_detector(hog: *mut CGpuHog, d: *const CSvmDetector);$/;"	f
cv_cuda_hog_set_gamma_correction	native/cuda/cuda.cc	/^void cv_cuda_hog_set_gamma_correction(cv::Ptr<cv::cuda::HOG>* hog, bool gamma) {$/;"	f
cv_cuda_hog_set_gamma_correction	src/cuda.rs	/^    fn cv_cuda_hog_set_gamma_correction(hog: *mut CGpuHog, gamma: bool);$/;"	f
cv_cuda_hog_set_group_threshold	native/cuda/cuda.cc	/^void cv_cuda_hog_set_group_threshold(cv::Ptr<cv::cuda::HOG>* hog, int group_threshold) {$/;"	f
cv_cuda_hog_set_group_threshold	src/cuda.rs	/^    fn cv_cuda_hog_set_group_threshold(hog: *mut CGpuHog, group_threshold: c_int);$/;"	f
cv_cuda_hog_set_hit_threshold	native/cuda/cuda.cc	/^void cv_cuda_hog_set_hit_threshold(cv::Ptr<cv::cuda::HOG>* hog, double hit_threshold) {$/;"	f
cv_cuda_hog_set_hit_threshold	src/cuda.rs	/^    fn cv_cuda_hog_set_hit_threshold(hog: *mut CGpuHog, hit_threshold: c_double);$/;"	f
cv_cuda_hog_set_l2hys_threshold	native/cuda/cuda.cc	/^void cv_cuda_hog_set_l2hys_threshold(cv::Ptr<cv::cuda::HOG>* hog, double l2hys_threshold) {$/;"	f
cv_cuda_hog_set_l2hys_threshold	src/cuda.rs	/^    fn cv_cuda_hog_set_l2hys_threshold(hog: *mut CGpuHog, l2hys_threshold: c_double);$/;"	f
cv_cuda_hog_set_num_levels	native/cuda/cuda.cc	/^void cv_cuda_hog_set_num_levels(cv::Ptr<cv::cuda::HOG>* hog, int num_levels) {$/;"	f
cv_cuda_hog_set_num_levels	src/cuda.rs	/^    fn cv_cuda_hog_set_num_levels(hog: *mut CGpuHog, num_levels: usize);$/;"	f
cv_cuda_hog_set_scale_factor	native/cuda/cuda.cc	/^void cv_cuda_hog_set_scale_factor(cv::Ptr<cv::cuda::HOG>* hog, double scale_factor) {$/;"	f
cv_cuda_hog_set_scale_factor	src/cuda.rs	/^    fn cv_cuda_hog_set_scale_factor(hog: *mut CGpuHog, scale_factor: c_double);$/;"	f
cv_cuda_hog_set_win_sigma	native/cuda/cuda.cc	/^void cv_cuda_hog_set_win_sigma(cv::Ptr<cv::cuda::HOG>* hog, double win_sigma) {$/;"	f
cv_cuda_hog_set_win_sigma	src/cuda.rs	/^    fn cv_cuda_hog_set_win_sigma(hog: *mut CGpuHog, win_sigma: c_double);$/;"	f
cv_cuda_hog_set_win_stride	native/cuda/cuda.cc	/^void cv_cuda_hog_set_win_stride(cv::Ptr<cv::cuda::HOG>* hog, Size2i win_stride) {$/;"	f
cv_cuda_hog_set_win_stride	src/cuda.rs	/^    fn cv_cuda_hog_set_win_stride(hog: *mut CGpuHog, win_stride: Size2i);$/;"	f
cv_cvt_color	native/imgproc.cc	/^void cv_cvt_color(cv::Mat* mat, cv::Mat* out, int code) {$/;"	f
cv_cvt_color	src/imgproc.rs	/^    fn cv_cvt_color(cmat: *const CMat, output: *mut CMat, code: ColorConversion);$/;"	f
cv_destroy_window	native/highgui.cc	/^void cv_destroy_window(const char* const winname) {$/;"	f
cv_destroy_window	src/highgui.rs	/^    fn cv_destroy_window(name: *const c_char);$/;"	f
cv_ellipse	native/imgproc.cc	/^void cv_ellipse(cv::Mat* mat,$/;"	f
cv_ellipse	src/imgproc.rs	/^    fn cv_ellipse($/;"	f
cv_hmm_drop	native/text.cc	/^void cv_hmm_drop(cv::Ptr<cv::text::OCRHMMDecoder>* ocr) {$/;"	f
cv_hmm_drop	src/text/hmm.rs	/^    fn cv_hmm_drop(ocr: *mut COCR);$/;"	f
cv_hmm_new	native/text.cc	/^void cv_hmm_new(const char* classifier_filename,$/;"	f
cv_hmm_new	src/text/hmm.rs	/^    fn cv_hmm_new($/;"	f
cv_hog_daimler_people_detector	native/objdetect.cc	/^void* cv_hog_daimler_people_detector() {$/;"	f
cv_hog_daimler_people_detector	src/objdetect.rs	/^    fn cv_hog_daimler_people_detector() -> *mut CSvmDetector;$/;"	f
cv_hog_default_people_detector	native/objdetect.cc	/^void* cv_hog_default_people_detector() {$/;"	f
cv_hog_default_people_detector	src/objdetect.rs	/^    fn cv_hog_default_people_detector() -> *mut CSvmDetector;$/;"	f
cv_hog_detect	native/objdetect.cc	/^void cv_hog_detect(cv::HOGDescriptor* hog,$/;"	f
cv_hog_detect	src/objdetect.rs	/^    fn cv_hog_detect($/;"	f
cv_hog_detector_drop	native/objdetect.cc	/^void cv_hog_detector_drop(std::vector<float>* detector) {$/;"	f
cv_hog_detector_drop	src/objdetect.rs	/^    fn cv_hog_detector_drop(d: *mut CSvmDetector);$/;"	f
cv_hog_drop	native/objdetect.cc	/^void cv_hog_drop(cv::HOGDescriptor* hog) {$/;"	f
cv_hog_drop	src/objdetect.rs	/^    fn cv_hog_drop(hog: *mut CHogDescriptor);$/;"	f
cv_hog_new	native/objdetect.cc	/^void* cv_hog_new() {$/;"	f
cv_hog_new	src/objdetect.rs	/^    fn cv_hog_new() -> *mut CHogDescriptor;$/;"	f
cv_hog_set_svm_detector	native/objdetect.cc	/^void cv_hog_set_svm_detector(cv::HOGDescriptor* hog, std::vector<float>* detector) {$/;"	f
cv_hog_set_svm_detector	src/objdetect.rs	/^    fn cv_hog_set_svm_detector(hog: *mut CHogDescriptor, svm: *mut CSvmDetector);$/;"	f
cv_holistic_drop	native/text.cc	/^void cv_holistic_drop(cv::Ptr<cv::text::OCRHolisticWordRecognizer>* ocr) {$/;"	f
cv_holistic_drop	src/text/holisticword.rs	/^    fn cv_holistic_drop(ocr: *mut COCR);$/;"	f
cv_holistic_new	native/text.cc	/^void cv_holistic_new(const char* archive_file,$/;"	f
cv_holistic_new	src/text/holisticword.rs	/^    fn cv_holistic_new($/;"	f
cv_imdecode	native/imcodecs.cc	/^void* cv_imdecode(const uint8_t* const buffer, size_t len, int flag) {$/;"	f
cv_imdecode	src/imgcodecs.rs	/^    fn cv_imdecode(buf: *const u8, l: usize, m: ImageReadMode) -> *mut CMat;$/;"	f
cv_imencode	native/imcodecs.cc	/^cv_imencode(const char* const ext, const cv::Mat* const image, const int* const flag_ptr, size_t flag_size) {$/;"	f
cv_imencode	src/imgcodecs.rs	/^    fn cv_imencode($/;"	f
cv_imread	native/imcodecs.cc	/^void* cv_imread(const char* const filename, int flags) {$/;"	f
cv_imread	src/imgcodecs.rs	/^    fn cv_imread(input: *const c_char, flags: ImageReadMode) -> *mut CMat;$/;"	f
cv_imshow	native/highgui.cc	/^void cv_imshow(const char* const winname, cv::Mat* mat) {$/;"	f
cv_imshow	src/highgui.rs	/^    fn cv_imshow(name: *const c_char, cmat: *mut CMat);$/;"	f
cv_line	native/imgproc.cc	/^void cv_line(cv::Mat* mat, Point2i pt1, Point2i pt2, Scalar color, int thickness, int linetype, int shift) {$/;"	f
cv_line	src/imgproc.rs	/^    fn cv_line($/;"	f
cv_mat_bitwise_and	native/mat.cc	/^void cv_mat_bitwise_and(const cv::Mat* const src1, const cv::Mat* const src2, cv::Mat* dst) {$/;"	f
cv_mat_bitwise_and	src/mat.rs	/^    fn cv_mat_bitwise_and(src1: *const CMat, src2: *const CMat, dst: *mut CMat);$/;"	f
cv_mat_bitwise_not	native/mat.cc	/^void cv_mat_bitwise_not(const cv::Mat* const src, cv::Mat* const dst) {$/;"	f
cv_mat_bitwise_not	src/mat.rs	/^    fn cv_mat_bitwise_not(src: *const CMat, dst: *mut CMat);$/;"	f
cv_mat_bitwise_or	native/mat.cc	/^void cv_mat_bitwise_or(const cv::Mat* const src1, const cv::Mat* const src2, cv::Mat* dst) {$/;"	f
cv_mat_bitwise_or	src/mat.rs	/^    fn cv_mat_bitwise_or(src1: *const CMat, src2: *const CMat, dst: *mut CMat);$/;"	f
cv_mat_bitwise_xor	native/mat.cc	/^void cv_mat_bitwise_xor(const cv::Mat* const src1, const cv::Mat* const src2, cv::Mat* dst) {$/;"	f
cv_mat_bitwise_xor	src/mat.rs	/^    fn cv_mat_bitwise_xor(src1: *const CMat, src2: *const CMat, dst: *mut CMat);$/;"	f
cv_mat_channels	native/mat.cc	/^int cv_mat_channels(const cv::Mat* const mat) {$/;"	f
cv_mat_channels	src/mat.rs	/^    fn cv_mat_channels(cmat: *const CMat) -> c_int;$/;"	f
cv_mat_cols	native/mat.cc	/^int cv_mat_cols(const cv::Mat* const mat) {$/;"	f
cv_mat_cols	src/mat.rs	/^    fn cv_mat_cols(cmat: *const CMat) -> c_int;$/;"	f
cv_mat_copy_make_border	native/mat.cc	/^void cv_mat_copy_make_border($/;"	f
cv_mat_copy_make_border	src/mat.rs	/^    fn cv_mat_copy_make_border($/;"	f
cv_mat_count_non_zero	native/mat.cc	/^int cv_mat_count_non_zero(const cv::Mat* const src) {$/;"	f
cv_mat_count_non_zero	src/mat.rs	/^    fn cv_mat_count_non_zero(src: *const CMat) -> c_int;$/;"	f
cv_mat_data	native/mat.cc	/^const uint8_t* cv_mat_data(const cv::Mat* const mat) {$/;"	f
cv_mat_data	src/mat.rs	/^    fn cv_mat_data(cmat: *const CMat) -> *const u8;$/;"	f
cv_mat_depth	native/mat.cc	/^int cv_mat_depth(const cv::Mat* const mat) {$/;"	f
cv_mat_depth	src/mat.rs	/^    fn cv_mat_depth(cmat: *const CMat) -> c_int;$/;"	f
cv_mat_drop	native/mat.cc	/^void cv_mat_drop(cv::Mat* mat) {$/;"	f
cv_mat_drop	src/mat.rs	/^    fn cv_mat_drop(mat: *mut CMat);$/;"	f
cv_mat_elem_size	native/mat.cc	/^size_t cv_mat_elem_size(const cv::Mat* const mat) {$/;"	f
cv_mat_elem_size	src/mat.rs	/^    fn cv_mat_elem_size(cmat: *const CMat) -> usize;$/;"	f
cv_mat_elem_size1	native/mat.cc	/^size_t cv_mat_elem_size1(const cv::Mat* const mat) {$/;"	f
cv_mat_elem_size1	src/mat.rs	/^    fn cv_mat_elem_size1(cmat: *const CMat) -> usize;$/;"	f
cv_mat_eye	native/mat.cc	/^void* cv_mat_eye(int rows, int cols, int type) {$/;"	f
cv_mat_eye	src/mat.rs	/^    fn cv_mat_eye(rows: c_int, cols: c_int, cv_type: CvType) -> *mut CMat;$/;"	f
cv_mat_flip	native/mat.cc	/^void cv_mat_flip(cv::Mat* image, int code) {$/;"	f
cv_mat_flip	src/mat.rs	/^    fn cv_mat_flip(src: *mut CMat, code: c_int);$/;"	f
cv_mat_from_buffer	native/mat.cc	/^void* cv_mat_from_buffer(int rows, int cols, int type, const uint8_t* buf) {$/;"	f
cv_mat_from_buffer	src/mat.rs	/^    fn cv_mat_from_buffer(rows: c_int, cols: c_int, t: c_int, buffer: *const u8) -> *mut CMat;$/;"	f
cv_mat_from_file_storage	native/mat.cc	/^void* cv_mat_from_file_storage(const char* path, const char* section) {$/;"	f
cv_mat_from_file_storage	src/mat.rs	/^    fn cv_mat_from_file_storage(path: *const c_char, section: *const c_char) -> *mut CMat;$/;"	f
cv_mat_from_gpu_mat	native/cuda/cuda.cc	/^void* cv_mat_from_gpu_mat(cv::cuda::GpuMat* gpu_image) {$/;"	f
cv_mat_from_gpu_mat	src/cuda.rs	/^    fn cv_mat_from_gpu_mat(gpu_mat: *mut CGpuMat) -> *mut CMat;$/;"	f
cv_mat_in_range	native/mat.cc	/^void cv_mat_in_range(cv::Mat* mat, Scalar lowerb, Scalar upperb, cv::Mat* dst) {$/;"	f
cv_mat_in_range	src/mat.rs	/^    fn cv_mat_in_range(cmat: *const CMat, lowerb: Scalar, upperb: Scalar, dst: *mut CMat);$/;"	f
cv_mat_is_valid	native/mat.cc	/^bool cv_mat_is_valid(cv::Mat* mat) {$/;"	f
cv_mat_is_valid	src/mat.rs	/^    fn cv_mat_is_valid(mat: *mut CMat) -> bool;$/;"	f
cv_mat_min_max_loc	native/mat.cc	/^void cv_mat_min_max_loc($/;"	f
cv_mat_min_max_loc	src/mat.rs	/^    fn cv_mat_min_max_loc($/;"	f
cv_mat_mix_channels	native/mat.cc	/^void cv_mat_mix_channels(cv::Mat* src, size_t nsrcs, cv::Mat* dst, size_t ndsts, const int* from_to, size_t npairs) {$/;"	f
cv_mat_mix_channels	src/mat.rs	/^    fn cv_mat_mix_channels($/;"	f
cv_mat_new	native/mat.cc	/^void* cv_mat_new() {$/;"	f
cv_mat_new	src/mat.rs	/^    fn cv_mat_new() -> *mut CMat;$/;"	f
cv_mat_new_with_size	native/mat.cc	/^void* cv_mat_new_with_size(int rows, int cols, int type) {$/;"	f
cv_mat_new_with_size	src/mat.rs	/^    fn cv_mat_new_with_size(rows: c_int, cols: c_int, t: c_int) -> *mut CMat;$/;"	f
cv_mat_normalize	native/mat.cc	/^void cv_mat_normalize(cv::Mat* src, cv::Mat* dst, double alpha, double beta, int norm_type) {$/;"	f
cv_mat_normalize	src/mat.rs	/^    fn cv_mat_normalize(csrc: *const CMat, cdst: *mut CMat, alpha: c_double, beta: c_double, norm_type: NormType);$/;"	f
cv_mat_roi	native/mat.cc	/^void* cv_mat_roi(cv::Mat* mat, Rect crect) {$/;"	f
cv_mat_roi	src/mat.rs	/^    fn cv_mat_roi(cmat: *const CMat, rect: Rect) -> *mut CMat;$/;"	f
cv_mat_rows	native/mat.cc	/^int cv_mat_rows(const cv::Mat* const mat) {$/;"	f
cv_mat_rows	src/mat.rs	/^    fn cv_mat_rows(cmat: *const CMat) -> c_int;$/;"	f
cv_mat_step1	native/mat.cc	/^size_t cv_mat_step1(const cv::Mat* const mat, int i) {$/;"	f
cv_mat_step1	src/mat.rs	/^    fn cv_mat_step1(cmat: *const CMat, i: c_int) -> usize;$/;"	f
cv_mat_total	native/mat.cc	/^size_t cv_mat_total(const cv::Mat* const mat) {$/;"	f
cv_mat_total	src/mat.rs	/^    fn cv_mat_total(cmat: *const CMat) -> usize;$/;"	f
cv_mat_type	native/mat.cc	/^int cv_mat_type(const cv::Mat* const mat) {$/;"	f
cv_mat_type	src/mat.rs	/^    fn cv_mat_type(cmat: *const CMat) -> CvType;$/;"	f
cv_mat_zeros	native/mat.cc	/^void* cv_mat_zeros(int rows, int cols, int type) {$/;"	f
cv_mat_zeros	src/mat.rs	/^    fn cv_mat_zeros(rows: c_int, cols: c_int, t: c_int) -> *mut CMat;$/;"	f
cv_matcher_add	native/features2d.cc	/^void cv_matcher_add(cv::Ptr<cv::DescriptorMatcher>& descriptorMatcher, CVec<cv::Mat*>& descriptors) {$/;"	f
cv_matcher_add	src/features2d/descriptor_matcher.rs	/^    fn cv_matcher_add(descriptor_matcher: *mut CDescriptorMatcher, descriptors: *const CVecView<*mut CMat>);$/;"	f
cv_matcher_drop	native/features2d.cc	/^void cv_matcher_drop(cv::Ptr<cv::DescriptorMatcher>* descriptorMatcher) {$/;"	f
cv_matcher_drop	src/features2d/descriptor_matcher.rs	/^    fn cv_matcher_drop(descriptor_matcher: *mut CDescriptorMatcher);$/;"	f
cv_matcher_is_empty	native/features2d.cc	/^bool cv_matcher_is_empty(cv::Ptr<cv::DescriptorMatcher>& descriptorMatcher) {$/;"	f
cv_matcher_is_empty	src/features2d/descriptor_matcher.rs	/^    fn cv_matcher_is_empty(descriptor_matcher: *mut CDescriptorMatcher) -> bool;$/;"	f
cv_matcher_knn_match	native/features2d.cc	/^void cv_matcher_knn_match(cv::Ptr<cv::DescriptorMatcher>& descriptorMatcher,$/;"	f
cv_matcher_knn_match	src/features2d/descriptor_matcher.rs	/^    fn cv_matcher_knn_match($/;"	f
cv_matcher_match	native/features2d.cc	/^void cv_matcher_match(cv::Ptr<cv::DescriptorMatcher>& descriptorMatcher,$/;"	f
cv_matcher_match	src/features2d/descriptor_matcher.rs	/^    fn cv_matcher_match($/;"	f
cv_matcher_match_two	native/features2d.cc	/^void cv_matcher_match_two(cv::Ptr<cv::DescriptorMatcher>& descriptorMatcher,$/;"	f
cv_matcher_match_two	src/features2d/descriptor_matcher.rs	/^    fn cv_matcher_match_two($/;"	f
cv_matcher_new	native/features2d.cc	/^void* cv_matcher_new(const char* descriptorMatcherType) {$/;"	f
cv_matcher_new	src/features2d/descriptor_matcher.rs	/^    fn cv_matcher_new(descriptor_matcher_type: *const c_char) -> *mut CDescriptorMatcher;$/;"	f
cv_matcher_train	native/features2d.cc	/^void cv_matcher_train(cv::Ptr<cv::DescriptorMatcher>& descriptorMatcher) {$/;"	f
cv_matcher_train	src/features2d/descriptor_matcher.rs	/^    fn cv_matcher_train(descriptor_matcher: *mut CDescriptorMatcher);$/;"	f
cv_mser_detect_and_compute	native/features2d.cc	/^void cv_mser_detect_and_compute(cv::Ptr<cv::MSER>* detector,$/;"	f
cv_mser_detect_regions	native/features2d.cc	/^void cv_mser_detect_regions(cv::Ptr<cv::MSER>* detector,$/;"	f
cv_mser_detect_regions	src/features2d/mser.rs	/^    fn cv_mser_detect_regions($/;"	f
cv_mser_drop	native/features2d.cc	/^void cv_mser_drop(cv::Ptr<cv::MSER>* detector) {$/;"	f
cv_mser_drop	src/features2d/mser.rs	/^    fn cv_mser_drop(cmser: *mut CMSER);$/;"	f
cv_mser_new	native/features2d.cc	/^void* cv_mser_new(int delta,$/;"	f
cv_mser_new	src/features2d/mser.rs	/^    fn cv_mser_new($/;"	f
cv_named_window	native/highgui.cc	/^void cv_named_window(const char* const winname, int flags) {$/;"	f
cv_named_window	src/highgui.rs	/^    fn cv_named_window(name: *const c_char, flags: WindowFlag);$/;"	f
cv_ocr_run	native/text.cc	/^void cv_ocr_run(cv::Ptr<cv::text::BaseOCR>& ocr,$/;"	f
cv_ocr_run	src/text/mod.rs	/^    fn cv_ocr_run($/;"	f
cv_pyr_down	native/imgproc.cc	/^void cv_pyr_down(cv::Mat* mat, cv::Mat* out) {$/;"	f
cv_pyr_down	src/imgproc.rs	/^    fn cv_pyr_down(cmat: *const CMat, output: *mut CMat);$/;"	f
cv_rectangle	native/imgproc.cc	/^void cv_rectangle(cv::Mat* mat, Rect crect, Scalar color, int thickness, int linetype) {$/;"	f
cv_rectangle	src/imgproc.rs	/^    fn cv_rectangle(cmat: *mut CMat, rect: Rect, color: Scalar, thickness: c_int, linetype: LineType);$/;"	f
cv_resize	native/imgproc.cc	/^void cv_resize(cv::Mat* from, cv::Mat* to, Size2i dsize, double fx, double fy, int interpolation) {$/;"	f
cv_resize	src/imgproc.rs	/^    fn cv_resize($/;"	f
cv_set_mouse_callback	native/highgui.cc	/^void cv_set_mouse_callback(const char* const winname, cv::MouseCallback on_mouse, void* userdata) {$/;"	f
cv_set_mouse_callback	src/highgui.rs	/^    fn cv_set_mouse_callback($/;"	f
cv_sift_detect_and_compute	native/features2d.cc	/^void cv_sift_detect_and_compute(cv::Ptr<cv::xfeatures2d::SIFT>* detector,$/;"	f
cv_sift_detect_and_compute	src/features2d/sift.rs	/^    fn cv_sift_detect_and_compute($/;"	f
cv_sift_drop	native/features2d.cc	/^void cv_sift_drop(cv::Ptr<cv::xfeatures2d::SIFT>* detector) {$/;"	f
cv_sift_drop	src/features2d/sift.rs	/^    fn cv_sift_drop(cmser: *mut CSIFT);$/;"	f
cv_sift_new	native/features2d.cc	/^void* cv_sift_new(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold, double sigma) {$/;"	f
cv_sift_new	src/features2d/sift.rs	/^    fn cv_sift_new($/;"	f
cv_surf_detect_and_compute	native/features2d.cc	/^void cv_surf_detect_and_compute(cv::Ptr<cv::xfeatures2d::SURF>* detector,$/;"	f
cv_surf_detect_and_compute	src/features2d/surf.rs	/^    fn cv_surf_detect_and_compute($/;"	f
cv_surf_drop	native/features2d.cc	/^void cv_surf_drop(cv::Ptr<cv::xfeatures2d::SURF>* detector) {$/;"	f
cv_surf_drop	src/features2d/surf.rs	/^    fn cv_surf_drop(cmser: *mut CSURF);$/;"	f
cv_surf_new	native/features2d.cc	/^void* cv_surf_new(double hessianThreshold, int nOctaves, int nOctaveLayers, bool extended, bool upright) {$/;"	f
cv_surf_new	src/features2d/surf.rs	/^    fn cv_surf_new($/;"	f
cv_term_criteria_drop	native/video.cc	/^void cv_term_criteria_drop(cv::TermCriteria* criteria) {$/;"	f
cv_term_criteria_drop	src/video.rs	/^        fn cv_term_criteria_drop(criteria: *mut CTermCriteria);$/;"	f
cv_term_criteria_new	native/video.cc	/^void* cv_term_criteria_new(int type, int count, double epsilon) {$/;"	f
cv_term_criteria_new	src/video.rs	/^        fn cv_term_criteria_new(t: TermType, count: c_int, epsilon: f64) -> *mut CTermCriteria;$/;"	f
cv_tesseract_drop	native/text.cc	/^void cv_tesseract_drop(cv::Ptr<cv::text::OCRTesseract>* ocr) {$/;"	f
cv_tesseract_drop	src/text/tesseract.rs	/^    fn cv_tesseract_drop(ocr: *mut COCR);$/;"	f
cv_tesseract_new	native/text.cc	/^void cv_tesseract_new(const char* datapath,$/;"	f
cv_tesseract_new	src/text/tesseract.rs	/^    fn cv_tesseract_new($/;"	f
cv_to_ffi	native/utils.cc	/^void cv_to_ffi(const cv::DMatch& source, DMatch* dest) {$/;"	f
cv_to_ffi	native/utils.cc	/^void cv_to_ffi(const cv::KeyPoint& source, KeyPoint* dest) {$/;"	f
cv_to_ffi	native/utils.cc	/^void cv_to_ffi(const cv::Point& source, Point2i* dest) {$/;"	f
cv_to_ffi	native/utils.cc	/^void cv_to_ffi(const cv::Rect& source, Rect* dest) {$/;"	f
cv_to_ffi	native/utils.cc	/^void cv_to_ffi(const std::string& source, CDisposableString* dest) {$/;"	f
cv_to_ffi	native/utils.h	/^void cv_to_ffi(const std::vector<T>& source, CVec<T>* dest) {$/;"	f
cv_to_ffi	native/utils.h	/^void cv_to_ffi(const std::vector<T>& source, CVec<U>* dest) {$/;"	f
cv_type	src/mat.rs	/^    pub fn cv_type(&self) -> CvType {$/;"	f
cv_vec_drop	native/common-rust.cc	/^void cv_vec_drop(CVec<void>* vec, unsigned int depth) {$/;"	f
cv_vec_drop	src/lib.rs	/^            fn cv_vec_drop(vec: *mut c_void, depth: u32);$/;"	f
cv_videocapture_drop	native/videoio.cc	/^void cv_videocapture_drop(cv::VideoCapture* cap) {$/;"	f
cv_videocapture_drop	src/videoio.rs	/^    fn cv_videocapture_drop(cap: *mut CVideoCapture);$/;"	f
cv_videocapture_from_file	native/videoio.cc	/^void* cv_videocapture_from_file(const char* const filename) {$/;"	f
cv_videocapture_from_file	src/videoio.rs	/^    fn cv_videocapture_from_file(path: *const c_char) -> *mut CVideoCapture;$/;"	f
cv_videocapture_get	native/videoio.cc	/^double cv_videocapture_get(cv::VideoCapture* cap, int property) {$/;"	f
cv_videocapture_get	src/videoio.rs	/^    fn cv_videocapture_get(cap: *mut CVideoCapture, property: CapProp) -> c_double;$/;"	f
cv_videocapture_is_opened	native/videoio.cc	/^bool cv_videocapture_is_opened(const cv::VideoCapture* const cap) {$/;"	f
cv_videocapture_is_opened	src/videoio.rs	/^    fn cv_videocapture_is_opened(ccap: *const CVideoCapture) -> bool;$/;"	f
cv_videocapture_new	native/videoio.cc	/^void* cv_videocapture_new(int index) {$/;"	f
cv_videocapture_new	src/videoio.rs	/^    fn cv_videocapture_new(index: c_int) -> *mut CVideoCapture;$/;"	f
cv_videocapture_read	native/videoio.cc	/^bool cv_videocapture_read(cv::VideoCapture* cap, cv::Mat* mat) {$/;"	f
cv_videocapture_read	src/videoio.rs	/^    fn cv_videocapture_read(v: *mut CVideoCapture, m: *mut CMat) -> bool;$/;"	f
cv_videocapture_set	native/videoio.cc	/^bool cv_videocapture_set(cv::VideoCapture* cap, int property, double value) {$/;"	f
cv_videocapture_set	src/videoio.rs	/^    fn cv_videocapture_set(cap: *mut CVideoCapture, property: CapProp, value: c_double) -> bool;$/;"	f
cv_videowriter_default	native/videoio.cc	/^void* cv_videowriter_default() {$/;"	f
cv_videowriter_default	src/videoio.rs	/^    fn cv_videowriter_default() -> *mut CvVideoWriter;$/;"	f
cv_videowriter_drop	native/videoio.cc	/^void cv_videowriter_drop(cv::VideoWriter* writer) {$/;"	f
cv_videowriter_drop	src/videoio.rs	/^    fn cv_videowriter_drop(w: *mut CvVideoWriter);$/;"	f
cv_videowriter_get	native/videoio.cc	/^double cv_videowriter_get(cv::VideoWriter* writer, int property) {$/;"	f
cv_videowriter_get	src/videoio.rs	/^    fn cv_videowriter_get(w: *mut CvVideoWriter, property: VideoWriterProperty) -> c_double;$/;"	f
cv_videowriter_is_opened	native/videoio.cc	/^bool cv_videowriter_is_opened(cv::VideoWriter* writer) {$/;"	f
cv_videowriter_is_opened	src/videoio.rs	/^    fn cv_videowriter_is_opened(w: *mut CvVideoWriter) -> bool;$/;"	f
cv_videowriter_new	native/videoio.cc	/^void* cv_videowriter_new(const char* const path, int fourcc, double fps, Size2i frame_size, bool is_color) {$/;"	f
cv_videowriter_new	src/videoio.rs	/^    fn cv_videowriter_new($/;"	f
cv_videowriter_open	native/videoio.cc	/^bool cv_videowriter_open($/;"	f
cv_videowriter_open	src/videoio.rs	/^    fn cv_videowriter_open($/;"	f
cv_videowriter_set	native/videoio.cc	/^bool cv_videowriter_set(cv::VideoWriter* writer, int property, double value) {$/;"	f
cv_videowriter_set	src/videoio.rs	/^    fn cv_videowriter_set(w: *mut CvVideoWriter, property: VideoWriterProperty, value: c_double) -> bool;$/;"	f
cv_videowriter_write	native/videoio.cc	/^void cv_videowriter_write(cv::VideoWriter* writer, cv::Mat* mat) {$/;"	f
cv_videowriter_write	src/videoio.rs	/^    fn cv_videowriter_write(w: *mut CvVideoWriter, m: *mut CMat);$/;"	f
cv_wait_key	native/highgui.cc	/^int cv_wait_key(int delay) {$/;"	f
cv_wait_key	src/highgui.rs	/^    fn cv_wait_key(delay_ms: c_int) -> c_int;$/;"	f
cvt_color	src/imgproc.rs	/^    pub fn cvt_color(&self, code: ColorConversion) -> Mat {$/;"	f
daimler_people_detector	src/objdetect.rs	/^    pub fn daimler_people_detector() -> SvmDetector {$/;"	f
data	src/mat.rs	/^    pub fn data(&self) -> &[u8] {$/;"	f
default	src/cuda.rs	/^    fn default() -> GpuHog {$/;"	f
default	src/cuda.rs	/^    pub fn default() -> GpuMat {$/;"	f
default	src/lib.rs	/^    fn default() -> Self {$/;"	f
default	src/objdetect.rs	/^    fn default() -> HogDescriptor {$/;"	f
default	src/objdetect.rs	/^    fn default() -> HogParams {$/;"	f
default	src/videoio.rs	/^    fn default() -> VideoWriter {$/;"	f
default_people_detector	src/objdetect.rs	/^    pub fn default_people_detector() -> SvmDetector {$/;"	f
delta	src/features2d/mser.rs	/^    pub fn delta(mut self, value: c_int) -> Self {$/;"	f
description	build.rs	/^    fn description(&self) -> &str {$/;"	f
descriptor_matcher	src/features2d/mod.rs	/^mod descriptor_matcher;$/;"	m
detect	src/cuda.rs	/^    fn detect(&self, image: &Mat) -> Vec<(Rect, f64)> {$/;"	f
detect	src/objdetect.rs	/^    fn detect(&self, image: &Mat) -> Vec<(Rect, f64)> {$/;"	f
detect	src/objdetect.rs	/^    fn detect(&self, image: &Mat) -> Vec<(Rect, f64)>;$/;"	f
detect_and_compute	src/features2d/mod.rs	/^    fn detect_and_compute(&self, image: &Mat, mask: &Mat) -> (Vec<KeyPoint>, Mat);$/;"	f
detect_and_compute	src/features2d/sift.rs	/^    fn detect_and_compute(&self, image: &Mat, mask: &Mat) -> (Vec<KeyPoint>, Mat) {$/;"	f
detect_and_compute	src/features2d/surf.rs	/^    fn detect_and_compute(&self, image: &Mat, mask: &Mat) -> (Vec<KeyPoint>, Mat) {$/;"	f
detect_multiscale	src/cuda.rs	/^    pub fn detect_multiscale(&self, mat: &GpuMat) -> Vec<Rect> {$/;"	f
detect_multiscale	src/objdetect.rs	/^    pub fn detect_multiscale(&self, mat: &Mat) -> Vec<Rect> {$/;"	f
detect_regions	src/features2d/mser.rs	/^    pub fn detect_regions(&self, image: &Mat) -> (Vec<Vec<Point2i>>, Vec<Rect>) {$/;"	f
detect_with_params	src/objdetect.rs	/^    pub fn detect_with_params($/;"	f
distance	native/common.h	/^    float distance;$/;"	m	struct:__anon10
drop	src/cuda.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/features2d/descriptor_matcher.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/features2d/mser.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/features2d/sift.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/features2d/surf.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/lib.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/mat.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/objdetect.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/text/hmm.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/text/holisticword.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/text/tesseract.rs	/^    fn drop(&mut self) {$/;"	f
drop	src/video.rs	/^        fn drop(&mut self) {$/;"	f
drop	src/videoio.rs	/^    fn drop(&mut self) {$/;"	f
edge_blur_size	src/features2d/mser.rs	/^    pub fn edge_blur_size(mut self, value: c_int) -> Self {$/;"	f
edge_threshold	src/features2d/sift.rs	/^    pub fn edge_threshold(mut self, value: f64) -> Self {$/;"	f
elem_size	src/mat.rs	/^    pub fn elem_size(&self) -> usize {$/;"	f
elem_size1	src/mat.rs	/^    pub fn elem_size1(&self) -> usize {$/;"	f
ellipse	src/imgproc.rs	/^    pub fn ellipse(&self, center: Point2i, axes: Size2i, angle: f64, start_angle: f64, end_angle: f64) {$/;"	f
ellipse_custom	src/imgproc.rs	/^    pub fn ellipse_custom($/;"	f
error	native/common.h	/^    CDisposableString error;$/;"	m	struct:Result
errors	src/lib.rs	/^pub mod errors;$/;"	m
extended	src/features2d/surf.rs	/^    pub fn extended(mut self, value: bool) -> Self {$/;"	f
eye	src/mat.rs	/^    pub fn eye(rows: i32, cols: i32, cv_type: CvType) -> Mat {$/;"	f
features	src/features2d/sift.rs	/^    pub fn features(mut self, value: c_int) -> Self {$/;"	f
features2d	src/lib.rs	/^pub mod features2d;$/;"	m
ffi_to_cv	native/utils.cc	/^void ffi_to_cv(const cv::Mat& source, cv::Mat* dest) {$/;"	f
ffi_to_cv	native/utils.h	/^void ffi_to_cv(const CVec<U*>& source, std::vector<T>* dest) {$/;"	f
flann_based_matcher	tests/test_features2d.rs	/^fn flann_based_matcher() {$/;"	f
flann_based_matcher_knn	tests/test_features2d.rs	/^fn flann_based_matcher_knn() {$/;"	f
flann_based_matcher_two	tests/test_features2d.rs	/^fn flann_based_matcher_two() {$/;"	f
flip	src/mat.rs	/^    pub fn flip(&mut self, code: FlipCode) {$/;"	f
fmt	build.rs	/^    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {$/;"	f
from	src/cuda.rs	/^    fn from(gpu_mat: GpuMat) -> Mat {$/;"	f
from	src/cuda.rs	/^    fn from(mat: Mat) -> GpuMat {$/;"	f
from_buffer	src/mat.rs	/^    pub fn from_buffer(rows: c_int, cols: c_int, cv_type: c_int, buf: &Vec<u8>) -> Mat {$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> (T, T, T) {$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> Self;$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> f32 {$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> f64 {$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> i16 {$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> i32 {$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> i8 {$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> u16 {$/;"	f
from_bytes	src/core.rs	/^    fn from_bytes(bytes: &[u8]) -> u8 {$/;"	f
from_callback	src/lib.rs	/^    pub fn from_callback<F: FnOnce(*mut CResult<T>)>(func: F) -> CResult<T> {$/;"	f
from_file_storage	src/mat.rs	/^    pub fn from_file_storage<P: AsRef<Path>>(path: P, section: &str) -> Result<Mat, Error> {$/;"	f
from_path	src/cuda.rs	/^    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<Self, Error> {$/;"	f
from_path	src/imgcodecs.rs	/^    pub fn from_path<P: AsRef<Path>>(path: P, flags: ImageReadMode) -> Result<Mat, Error> {$/;"	f
from_path	src/objdetect.rs	/^    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<Self, Error> {$/;"	f
from_path	src/videoio.rs	/^    pub fn from_path(path: &str) -> Self {$/;"	f
get	src/videoio.rs	/^    pub fn get(&self, property: CapProp) -> Option<f64> {$/;"	f
get	src/videoio.rs	/^    pub fn get(&self, property: VideoWriterProperty) -> Option<f64> {$/;"	f
get_asset_path	tests/utils.rs	/^pub fn get_asset_path(name: &'static str) -> PathBuf {$/;"	f
get_classifier_size	src/cuda.rs	/^    pub fn get_classifier_size(&self) -> Size2i {$/;"	f
get_files	build.rs	/^fn get_files(path: &str) -> Vec<std::path::PathBuf> {$/;"	f
get_find_largest_object_flag	src/cuda.rs	/^    pub fn get_find_largest_object_flag(&self) -> bool {$/;"	f
get_image_histogram	tests/test_imgproc.rs	/^fn get_image_histogram(path: &'static str) -> Mat {$/;"	f
get_max_num_objects	src/cuda.rs	/^    pub fn get_max_num_objects(&self) -> c_int {$/;"	f
get_max_object_size	src/cuda.rs	/^    pub fn get_max_object_size(&self) -> Size2i {$/;"	f
get_min_neighbors	src/cuda.rs	/^    pub fn get_min_neighbors(&self) -> c_int {$/;"	f
get_min_object_size	src/cuda.rs	/^    pub fn get_min_object_size(&self) -> Size2i {$/;"	f
get_scale_factor	src/cuda.rs	/^    pub fn get_scale_factor(&self) -> f64 {$/;"	f
get_value	src/text/hmm.rs	/^    fn get_value(&self) -> *mut COCR {$/;"	f
get_value	src/text/holisticword.rs	/^    fn get_value(&self) -> *mut COCR {$/;"	f
get_value	src/text/mod.rs	/^        fn get_value(&self) -> *mut COCR;$/;"	f
get_value	src/text/tesseract.rs	/^    fn get_value(&self) -> *mut COCR {$/;"	f
height	native/common.h	/^    float height;$/;"	m	struct:__anon5
height	native/common.h	/^    int height;$/;"	m	struct:__anon4
height	native/common.h	/^    int height;$/;"	m	struct:__anon6
hessian_threshold	src/features2d/surf.rs	/^    pub fn hessian_threshold(mut self, value: f64) -> Self {$/;"	f
highgui	src/lib.rs	/^pub mod highgui;$/;"	m
highgui_destroy_window	src/highgui.rs	/^pub fn highgui_destroy_window(name: &str) {$/;"	f
highgui_named_window	src/highgui.rs	/^pub fn highgui_named_window(name: &str, flags: WindowFlag) -> Result<(), Error> {$/;"	f
highgui_set_mouse_callback	src/highgui.rs	/^pub fn highgui_set_mouse_callback(name: &str, on_mouse: MouseCallback, user_data: *mut c_void) -> Result<(), Error> {$/;"	f
hmm	src/text/mod.rs	/^mod hmm;$/;"	m
holisticword	src/text/mod.rs	/^mod holisticword;$/;"	m
image_decode	src/imgcodecs.rs	/^    pub fn image_decode(buf: &[u8], mode: ImageReadMode) -> Mat {$/;"	f
image_encode	src/imgcodecs.rs	/^    pub fn image_encode(&self, ext: &str, flags: Vec<ImageWriteMode>) -> Result<Vec<u8>, Error> {$/;"	f
imgIdx	native/common.h	/^    int imgIdx;$/;"	m	struct:__anon10
imgcodecs	src/lib.rs	/^pub mod imgcodecs;$/;"	m
imgproc	src/lib.rs	/^pub mod imgproc;$/;"	m
in_range	src/mat.rs	/^    pub fn in_range(&self, lowerb: Scalar, upperb: Scalar) -> Mat {$/;"	f
into	src/features2d/mser.rs	/^    fn into(self) -> MSER {$/;"	f
into	src/features2d/sift.rs	/^    fn into(self) -> SIFT {$/;"	f
into	src/features2d/surf.rs	/^    fn into(self) -> SURF {$/;"	f
into	src/lib.rs	/^    fn into(self) -> Result<T, String> {$/;"	f
into	src/mat.rs	/^    fn into(self) -> CMat {$/;"	f
is_empty	src/features2d/descriptor_matcher.rs	/^    pub fn is_empty(&self) -> bool {$/;"	f
is_open	src/videoio.rs	/^    pub fn is_open(&self) -> bool {$/;"	f
is_valid	src/mat.rs	/^    pub fn is_valid(&self) -> bool {$/;"	f
knn_match	src/features2d/descriptor_matcher.rs	/^    pub fn knn_match(&self, query_descriptors: &Mat, k: usize) -> Vec<Vec<DMatch>> {$/;"	f
line	src/imgproc.rs	/^    pub fn line(&self, pt1: Point2i, pt2: Point2i) {$/;"	f
line_custom	src/imgproc.rs	/^    pub fn line_custom($/;"	f
load	src/objdetect.rs	/^    pub fn load<P: AsRef<Path>>(&self, path: P) -> Result<(), Error> {$/;"	f
load_avg_towncentre	tests/utils.rs	/^pub fn load_avg_towncentre() -> Mat {$/;"	f
load_frontal_face	tests/utils.rs	/^pub fn load_frontal_face() -> CascadeClassifier {$/;"	f
load_image_as_buf	tests/utils.rs	/^fn load_image_as_buf<P: AsRef<Path>>(img: P) -> Vec<u8> {$/;"	f
load_lenna	tests/utils.rs	/^pub fn load_lenna() -> Mat {$/;"	f
load_lenna_as_buf	tests/utils.rs	/^pub fn load_lenna_as_buf() -> Vec<u8> {$/;"	f
load_messi_color	tests/utils.rs	/^pub fn load_messi_color() -> Mat {$/;"	f
load_physicists	tests/utils.rs	/^pub fn load_physicists() -> Mat {$/;"	f
macros	src/text/mod.rs	/^mod macros;$/;"	m
main	build.rs	/^fn main() {$/;"	f
main	examples/calc_hist.rs	/^fn main() {$/;"	f
main	examples/camshift.rs	/^fn main() {$/;"	f
main	examples/display_image.rs	/^fn main() {$/;"	f
main	examples/face_detect.rs	/^fn main() {$/;"	f
main	examples/hog.rs	/^fn main() {$/;"	f
main	examples/hs_hist.rs	/^fn main() {$/;"	f
main	examples/video_capture.rs	/^fn main() {$/;"	f
mat	src/lib.rs	/^pub mod mat;$/;"	m
match_	src/features2d/descriptor_matcher.rs	/^    pub fn match_(&self, query_descriptors: &Mat) -> Vec<DMatch> {$/;"	f
match_two	src/features2d/descriptor_matcher.rs	/^    pub fn match_two(&self, query_descriptors: &Mat, train_descriptors: &Mat) -> Vec<DMatch> {$/;"	f
matrix_to_vec	src/imgproc.rs	/^    fn matrix_to_vec<T, MElem: AsRef<[T]>, M: AsRef<[MElem]>>(value: M) -> Vec<*const T> {$/;"	f
max_area	src/features2d/mser.rs	/^    pub fn max_area(mut self, value: c_int) -> Self {$/;"	f
max_evolution	src/features2d/mser.rs	/^    pub fn max_evolution(mut self, value: c_int) -> Self {$/;"	f
max_variation	src/features2d/mser.rs	/^    pub fn max_variation(mut self, value: f64) -> Self {$/;"	f
min_area	src/features2d/mser.rs	/^    pub fn min_area(mut self, value: c_int) -> Self {$/;"	f
min_diversity	src/features2d/mser.rs	/^    pub fn min_diversity(mut self, value: f64) -> Self {$/;"	f
min_margin	src/features2d/mser.rs	/^    pub fn min_margin(mut self, value: f64) -> Self {$/;"	f
min_max_loc	src/mat.rs	/^    pub fn min_max_loc(&self, mask: &Mat) -> (f64, f64, Point2i, Point2i) {$/;"	f
mix_channels	src/mat.rs	/^    pub fn mix_channels<T: AsRef<[(c_int, c_int)]>>(&self, nsrcs: usize, ndsts: usize, from_to: T) -> Mat {$/;"	f
mser	src/features2d/mod.rs	/^mod mser;$/;"	m
mser_lenna_detect	tests/test_features2d.rs	/^fn mser_lenna_detect() {$/;"	f
new	src/core.rs	/^    pub fn new(v0: c_int, v1: c_int, v2: c_int, v3: c_int) -> Self {$/;"	f
new	src/core.rs	/^    pub fn new(width: c_int, height: c_int) -> Self {$/;"	f
new	src/core.rs	/^    pub fn new(x: c_int, y: c_int) -> Self {$/;"	f
new	src/core.rs	/^    pub fn new(x: c_int, y: c_int, width: c_int, height: c_int) -> Self {$/;"	f
new	src/core.rs	/^    pub fn new(x: f32, y: f32) -> Self {$/;"	f
new	src/cuda.rs	/^    pub fn new(win_size: Size2i, block_size: Size2i, block_stride: Size2i, cell_size: Size2i, nbins: c_int) -> GpuHog {$/;"	f
new	src/features2d/descriptor_matcher.rs	/^    pub fn new(descriptor_matcher_type: DescriptorMatcherType) -> DescriptorMatcher {$/;"	f
new	src/features2d/mser.rs	/^    pub fn new($/;"	f
new	src/features2d/sift.rs	/^    pub fn new($/;"	f
new	src/features2d/surf.rs	/^    pub fn new(hessian_threshold: f64, octaves: c_int, octave_layers: c_int, extended: bool, upright: bool) -> Self {$/;"	f
new	src/mat.rs	/^    pub fn new() -> Mat {$/;"	f
new	src/objdetect.rs	/^    pub fn new() -> CascadeClassifier {$/;"	f
new	src/text/hmm.rs	/^    pub fn new<P: AsRef<Path>>($/;"	f
new	src/text/holisticword.rs	/^    pub fn new<PArch: AsRef<Path>, PWeights: AsRef<Path>, PWords: AsRef<Path>>($/;"	f
new	src/text/tesseract.rs	/^    pub fn new($/;"	f
new	src/video.rs	/^        pub fn new(t: TermType, max_count: c_int, epsilon: f64) -> Self {$/;"	f
new	src/videoio.rs	/^    pub fn new(index: c_int) -> Self {$/;"	f
new	src/videoio.rs	/^    pub fn new(path: &str, fourcc: c_int, fps: f64, frame_size: Size2i, is_color: bool) -> VideoWriter {$/;"	f
normalize	src/mat.rs	/^    pub fn normalize(&self, alpha: f64, beta: f64, t: NormType) -> Mat {$/;"	f
normalize_to_mat	src/core.rs	/^    pub fn normalize_to_mat(&self, mat: &Mat) -> Rect {$/;"	f
normalize_to_mat	src/core.rs	/^    pub fn normalize_to_mat(&self, mat: &Mat) -> Rect2f {$/;"	f
not	src/mat.rs	/^    fn not(self) -> Self::Output {$/;"	f
objdetect	src/lib.rs	/^pub mod objdetect;$/;"	m
ocr_hmm_test	tests/test_text.rs	/^fn ocr_hmm_test() {$/;"	f
ocr_holistic_word_panic	tests/test_text.rs	/^fn ocr_holistic_word_panic() {$/;"	f
ocr_tesseract_test_line	tests/test_text.rs	/^    fn ocr_tesseract_test_line() {$/;"	f
ocr_tesseract_test_word	tests/test_text.rs	/^    fn ocr_tesseract_test_word() {$/;"	f
octave	native/common.h	/^    int octave;$/;"	m	struct:__anon9
octave_layers	src/features2d/sift.rs	/^    pub fn octave_layers(mut self, value: c_int) -> Self {$/;"	f
octave_layers	src/features2d/surf.rs	/^    pub fn octave_layers(mut self, value: c_int) -> Self {$/;"	f
octaves	src/features2d/surf.rs	/^    pub fn octaves(mut self, value: c_int) -> Self {$/;"	f
on_mouse	examples/camshift.rs	/^fn on_mouse(event: MouseEventType, x: i32, y: i32, _: i32, data: MouseCallbackData) {$/;"	f
open	src/videoio.rs	/^    pub fn open(&self, path: &str, fourcc: c_int, fps: f64, frame_size: Size2i, is_color: bool) -> bool {$/;"	f
opencv_include	build.rs	/^fn opencv_include() -> &'static str {$/;"	f
opencv_include	build.rs	/^fn opencv_include() -> String {$/;"	f
opencv_link	build.rs	/^fn opencv_link() {$/;"	f
pack	src/lib.rs	/^    fn pack(v: &Self::In) -> Self {$/;"	f
pack	src/lib.rs	/^    fn pack(v: &Self::In) -> Self;$/;"	f
pack	src/lib.rs	/^    fn pack(v: &T) -> Self {$/;"	f
pack	src/lib.rs	/^fn pack<T, U: Sized, F>(v: &Vec<T>, mut f: F) -> CVecView<U>$/;"	f
path_to_cstring	src/lib.rs	/^fn path_to_cstring<P: AsRef<Path>>(path: P) -> Result<CString, Error> {$/;"	f
path_to_cstring	src/text/macros.rs	/^macro_rules! path_to_cstring {$/;"	d
pixel_eq	tests/test_basic_ops.rs	/^fn pixel_eq(a: u8, b: u8) -> bool {$/;"	f
points	src/core.rs	/^    pub fn points(&self) -> [Point2f; 4] {$/;"	f
print_usage	examples/hog.rs	/^fn print_usage(program: &str, opts: getopts::Options) {$/;"	f
private	src/text/mod.rs	/^mod private {$/;"	m
pt	native/common.h	/^    Point2f pt;$/;"	m	struct:__anon9
pyr_down	src/imgproc.rs	/^    pub fn pyr_down(&self) -> Mat {$/;"	f
queryIdx	native/common.h	/^    int queryIdx;$/;"	m	struct:__anon10
read	src/videoio.rs	/^    pub fn read(&self) -> Option<Mat> {$/;"	f
rectangle	src/imgproc.rs	/^    pub fn rectangle(&self, rect: Rect) {$/;"	f
rectangle2f	src/imgproc.rs	/^    pub fn rectangle2f(&self, rect: Rect2f) {$/;"	f
rectangle_custom	src/imgproc.rs	/^    pub fn rectangle_custom(&self, rect: Rect, color: Scalar, thickness: c_int, linetype: LineType) {$/;"	f
resize_by	src/imgproc.rs	/^    pub fn resize_by(&self, fx: f64, fy: f64, interpolation: InterpolationFlag) -> Mat {$/;"	f
resize_to	src/imgproc.rs	/^    pub fn resize_to(&self, dsize: Size2i, interpolation: InterpolationFlag) -> Mat {$/;"	f
response	native/common.h	/^    float response;$/;"	m	struct:__anon9
return_score	src/cuda.rs	/^    pub fn return_score(&mut self, should: bool) {$/;"	f
roi	src/mat.rs	/^    pub fn roi(&self, rect: Rect) -> Mat {$/;"	f
run	examples/hog.rs	/^fn run() -> Result<()> {$/;"	f
run	src/text/mod.rs	/^    fn run(&self, image: &Mat, component_level: ComponentLevel) -> (String, Vec<Rect>, Vec<String>, Vec<f32>) {$/;"	f
run	src/text/mod.rs	/^    fn run(&self, image: &Mat, component_level: ComponentLevel) -> (String, Vec<Rect>, Vec<String>, Vec<f32>);$/;"	f
run_detect_for_image	examples/hog.rs	/^fn run_detect_for_image<P: AsRef<Path>, OD: ObjectDetect>(detector: &mut OD, path: P, show: bool, measure: bool) {$/;"	f
scale	src/core.rs	/^    pub fn scale(&self, ratio: f32) -> Rect {$/;"	f
set	src/videoio.rs	/^    pub fn set(&self, property: CapProp, value: f64) -> bool {$/;"	f
set	src/videoio.rs	/^    pub fn set(&self, property: VideoWriterProperty, value: f64) -> bool {$/;"	f
set_find_largest_object	src/cuda.rs	/^    pub fn set_find_largest_object(&mut self, value: bool) {$/;"	f
set_max_num_objects	src/cuda.rs	/^    pub fn set_max_num_objects(&mut self, max: c_int) {$/;"	f
set_max_object_size	src/cuda.rs	/^    pub fn set_max_object_size(&mut self, max: Size2i) {$/;"	f
set_min_neighbors	src/cuda.rs	/^    pub fn set_min_neighbors(&mut self, min: c_int) {$/;"	f
set_min_object_size	src/cuda.rs	/^    pub fn set_min_object_size(&mut self, min: Size2i) {$/;"	f
set_scale_factor	src/cuda.rs	/^    pub fn set_scale_factor(&mut self, factor: f64) {$/;"	f
set_svm_detector	src/cuda.rs	/^    pub fn set_svm_detector(&mut self, detector: SvmDetector) {$/;"	f
set_svm_detector	src/objdetect.rs	/^    pub fn set_svm_detector(&mut self, detector: SvmDetector) {$/;"	f
show	src/highgui.rs	/^    fn show(&self, name: &str, delay: c_int) -> Result<(), Error> {$/;"	f
show	src/highgui.rs	/^    fn show(&self, name: &str, delay: c_int) -> Result<(), Error>;$/;"	f
sift	src/features2d/mod.rs	/^mod sift;$/;"	m
sift_lenna_detect_and_compute	tests/test_features2d.rs	/^fn sift_lenna_detect_and_compute() {$/;"	f
sigma	src/features2d/sift.rs	/^    pub fn sigma(mut self, value: f64) -> Self {$/;"	f
size	native/common.h	/^    Size2f size;$/;"	m	struct:__anon7
size	native/common.h	/^    float size;$/;"	m	struct:__anon9
size	native/common.h	/^    size_t size;$/;"	m	struct:CVec
size	native/imcodecs.h	/^    size_t size;$/;"	m	struct:__anon1
size	src/mat.rs	/^    pub fn size(&self) -> Size2i {$/;"	f
status	native/imcodecs.h	/^    bool status;$/;"	m	struct:__anon1
std::error::Error for BuildError	build.rs	/^impl std::error::Error for BuildError {$/;"	i
std::fmt::Display for BuildError	build.rs	/^impl std::fmt::Display for BuildError {$/;"	i
step1	src/mat.rs	/^    pub fn step1(&self, i: c_int) -> usize {$/;"	f
string_to_cstring	src/text/macros.rs	/^macro_rules! string_to_cstring {$/;"	d
surf	src/features2d/mod.rs	/^mod surf;$/;"	m
surf_lenna_detect_and_compute	tests/test_features2d.rs	/^fn surf_lenna_detect_and_compute() {$/;"	f
tesseract	src/text/mod.rs	/^mod tesseract;$/;"	m
tesseract	tests/test_text.rs	/^mod tesseract {$/;"	m
test_4cc	tests/test_video.rs	/^fn test_4cc(string: &'static str, integer: u32) {$/;"	f
test_accessing_pixel	tests/test_basic_ops.rs	/^fn test_accessing_pixel() {$/;"	f
test_ayuv	tests/test_video.rs	/^fn test_ayuv() {$/;"	f
test_cascade_lenna	tests/test_objdetect.rs	/^fn test_cascade_lenna() {$/;"	f
test_cljr	tests/test_video.rs	/^fn test_cljr() {$/;"	f
test_mat_type	tests/test_basic_ops.rs	/^fn test_mat_type() {$/;"	f
test_pedestrian_detection	tests/test_objdetect.rs	/^fn test_pedestrian_detection() {$/;"	f
test_uyvp	tests/test_video.rs	/^fn test_uyvp() {$/;"	f
test_vyuy	tests/test_video.rs	/^fn test_vyuy() {$/;"	f
text	src/lib.rs	/^pub mod text;$/;"	m
timed	tests/utils.rs	/^pub fn timed<F>(label: &str, inner: F)$/;"	f
timed_multiple	tests/utils.rs	/^pub fn timed_multiple<F>(label: &str, iteration: usize, mut inner: F)$/;"	f
to_nullable_string	src/text/tesseract.rs	/^fn to_nullable_string(value: &Option<CString>) -> *const c_char {$/;"	f
total	src/mat.rs	/^    pub fn total(&self) -> usize {$/;"	f
tracking	src/video.rs	/^pub mod tracking {$/;"	m
train	src/features2d/descriptor_matcher.rs	/^    pub fn train(&self) {$/;"	f
trainIdx	native/common.h	/^    int trainIdx;$/;"	m	struct:__anon10
try_opencv_link	build.rs	/^fn try_opencv_link() -> Result<(), Box<std::error::Error>> {$/;"	f
unpack	src/lib.rs	/^    fn unpack(&self) -> Self::Out {$/;"	f
unpack	src/lib.rs	/^    fn unpack(&self) -> Self::Out;$/;"	f
unpack	src/lib.rs	/^unsafe fn unpack<T: NestedVec, U, F>(v: &CVec<T>, mut f: F) -> Vec<U>$/;"	f
unwrap_or_null	src/text/tesseract.rs	/^fn unwrap_or_null(value: &Option<*const c_char>) -> *const c_char {$/;"	f
update_params	src/cuda.rs	/^    fn update_params(inner: *mut CGpuHog, params: &mut HogParams) {$/;"	f
upload	src/cuda.rs	/^    pub fn upload(&mut self, mat: &Mat) {$/;"	f
upright	src/features2d/surf.rs	/^    pub fn upright(mut self, value: bool) -> Self {$/;"	f
utils	tests/benchmark.rs	/^mod utils;$/;"	m
utils	tests/test_basic_ops.rs	/^mod utils;$/;"	m
utils	tests/test_features2d.rs	/^mod utils;$/;"	m
utils	tests/test_imgproc.rs	/^mod utils;$/;"	m
utils	tests/test_objdetect.rs	/^mod utils;$/;"	m
utils	tests/test_text.rs	/^mod utils;$/;"	m
utils	tests/test_video.rs	/^mod utils;$/;"	m
v0	native/common.h	/^    int v0;$/;"	m	struct:__anon8
v1	native/common.h	/^    int v1;$/;"	m	struct:__anon8
v2	native/common.h	/^    int v2;$/;"	m	struct:__anon8
v3	native/common.h	/^    int v3;$/;"	m	struct:__anon8
value	native/common.h	/^    T value;$/;"	m	struct:Result
value	native/common.h	/^    const char* value;$/;"	m	struct:__anon11
video	src/lib.rs	/^pub mod video;$/;"	m
videoio	src/lib.rs	/^pub mod videoio;$/;"	m
width	native/common.h	/^    float width;$/;"	m	struct:__anon5
width	native/common.h	/^    int width;$/;"	m	struct:__anon4
width	native/common.h	/^    int width;$/;"	m	struct:__anon6
with_params	src/cuda.rs	/^    pub fn with_params(params: HogParams) -> GpuHog {$/;"	f
with_params	src/objdetect.rs	/^    pub fn with_params(params: HogParams) -> HogDescriptor {$/;"	f
with_size	src/mat.rs	/^    pub fn with_size(rows: c_int, cols: c_int, t: c_int) -> Self {$/;"	f
write	src/videoio.rs	/^    pub fn write(&self, mat: &Mat) {$/;"	f
x	native/common.h	/^    float x;$/;"	m	struct:__anon3
x	native/common.h	/^    int x;$/;"	m	struct:__anon2
x	native/common.h	/^    int x;$/;"	m	struct:__anon6
y	native/common.h	/^    float y;$/;"	m	struct:__anon3
y	native/common.h	/^    int y;$/;"	m	struct:__anon2
y	native/common.h	/^    int y;$/;"	m	struct:__anon6
zeros	src/mat.rs	/^    pub fn zeros(rows: c_int, cols: c_int, t: c_int) -> Self {$/;"	f
